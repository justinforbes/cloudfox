package shared

import (
	"fmt"
	"strings"

	"github.com/BishopFox/cloudfox/internal"
)

// LootFileManager helps manage loot file creation and content addition
// for GCP modules with per-project organization.
type LootFileManager struct {
	// LootMap stores loot files organized by projectID -> lootFileName -> LootFile
	LootMap map[string]map[string]*internal.LootFile
}

// NewLootFileManager creates a new LootFileManager
func NewLootFileManager() *LootFileManager {
	return &LootFileManager{
		LootMap: make(map[string]map[string]*internal.LootFile),
	}
}

// InitializeProject ensures the project has an initialized loot map
func (l *LootFileManager) InitializeProject(projectID string) {
	if l.LootMap[projectID] == nil {
		l.LootMap[projectID] = make(map[string]*internal.LootFile)
	}
}

// CreateLootFile creates a new loot file for a project with a header
func (l *LootFileManager) CreateLootFile(projectID, fileName, header string) {
	l.InitializeProject(projectID)
	l.LootMap[projectID][fileName] = &internal.LootFile{
		Name:     fileName,
		Contents: header,
	}
}

// AddToLoot adds content to a loot file
func (l *LootFileManager) AddToLoot(projectID, fileName, content string) {
	l.InitializeProject(projectID)
	if lootFile, exists := l.LootMap[projectID][fileName]; exists && lootFile != nil {
		lootFile.Contents += content
	}
}

// GetLootFile retrieves a loot file for a project
func (l *LootFileManager) GetLootFile(projectID, fileName string) *internal.LootFile {
	if projectLoot, exists := l.LootMap[projectID]; exists {
		return projectLoot[fileName]
	}
	return nil
}

// GetAllLootFiles returns all loot files across all projects as a flat slice
func (l *LootFileManager) GetAllLootFiles() []internal.LootFile {
	var allLoot []internal.LootFile
	for _, projectLoot := range l.LootMap {
		for _, lootFile := range projectLoot {
			if lootFile != nil && lootFile.Contents != "" {
				allLoot = append(allLoot, *lootFile)
			}
		}
	}
	return allLoot
}

// GetProjectLootFiles returns all loot files for a specific project
func (l *LootFileManager) GetProjectLootFiles(projectID string) []internal.LootFile {
	var lootFiles []internal.LootFile
	if projectLoot, exists := l.LootMap[projectID]; exists {
		for _, lootFile := range projectLoot {
			if lootFile != nil && lootFile.Contents != "" {
				lootFiles = append(lootFiles, *lootFile)
			}
		}
	}
	return lootFiles
}

// Standard loot file name suffixes
const (
	LootSuffixCommands       = "commands"
	LootSuffixExploitation   = "exploitation"
	LootSuffixEnumeration    = "enumeration"
	LootSuffixPrivesc        = "privesc"
	LootSuffixLateralMove    = "lateral-movement"
	LootSuffixDataExfil      = "data-exfiltration"
	LootSuffixHighPrivilege  = "high-privilege"
	LootSuffixSecurityRisks  = "security-risks"
	LootSuffixCredentials    = "credentials"
	LootSuffixSensitiveFiles = "sensitive-files"
)

// LootFileName generates a standardized loot file name
func LootFileName(moduleName, suffix string) string {
	return moduleName + "-" + suffix
}

// Standard loot file headers

// LootHeaderCommands returns a standard header for command loot files
func LootHeaderCommands(moduleName, description string) string {
	return fmt.Sprintf(`# %s - Exploitation Commands
# Generated by CloudFox
# %s
#
# Execute these commands to interact with discovered resources.
# Always ensure you have proper authorization before running these commands.

`, moduleName, description)
}

// LootHeaderEnumeration returns a standard header for enumeration loot files
func LootHeaderEnumeration(moduleName, description string) string {
	return fmt.Sprintf(`# %s - Further Enumeration Commands
# Generated by CloudFox
# %s
#
# Execute these commands to gather additional information.

`, moduleName, description)
}

// LootHeaderSecurityRisks returns a standard header for security risk loot files
func LootHeaderSecurityRisks(moduleName string) string {
	return fmt.Sprintf(`# %s - Security Risks
# Generated by CloudFox
#
# This file lists potential security issues discovered during enumeration.

`, moduleName)
}

// Command formatting helpers

// FormatGcloudCommand formats a gcloud CLI command for loot files
func FormatGcloudCommand(comment, command string) string {
	if comment != "" {
		return fmt.Sprintf("# %s\n%s\n\n", comment, command)
	}
	return fmt.Sprintf("%s\n\n", command)
}

// FormatGsutilCommand formats a gsutil command for loot files
func FormatGsutilCommand(comment, command string) string {
	return FormatGcloudCommand(comment, command)
}

// FormatBqCommand formats a bq CLI command for loot files
func FormatBqCommand(comment, command string) string {
	return FormatGcloudCommand(comment, command)
}

// FormatKubectlCommand formats a kubectl command for loot files
func FormatKubectlCommand(comment, command string) string {
	return FormatGcloudCommand(comment, command)
}

// FormatCurlCommand formats a curl command for loot files
func FormatCurlCommand(comment, command string) string {
	return FormatGcloudCommand(comment, command)
}

// FormatLootSection formats a section with a header and multiple commands
func FormatLootSection(sectionHeader string, commands []string) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("#############################################\n"))
	sb.WriteString(fmt.Sprintf("# %s\n", sectionHeader))
	sb.WriteString(fmt.Sprintf("#############################################\n\n"))
	for _, cmd := range commands {
		sb.WriteString(cmd)
		sb.WriteString("\n")
	}
	sb.WriteString("\n")
	return sb.String()
}

// FormatExploitEntry formats a single exploitation entry for loot files
func FormatExploitEntry(title, description, command string) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("#############################################\n"))
	sb.WriteString(fmt.Sprintf("# %s\n", title))
	if description != "" {
		sb.WriteString(fmt.Sprintf("# %s\n", description))
	}
	sb.WriteString(fmt.Sprintf("#############################################\n"))
	sb.WriteString(command)
	sb.WriteString("\n\n")
	return sb.String()
}

// FormatRiskEntry formats a risk finding for loot files
func FormatRiskEntry(riskLevel, resourceType, resourceName, description string) string {
	return fmt.Sprintf("[%s] %s: %s\n  Description: %s\n\n",
		riskLevel, resourceType, resourceName, description)
}

// Common GCP command templates

// GcloudDescribeInstance returns a gcloud command to describe an instance
func GcloudDescribeInstance(projectID, zone, instanceName string) string {
	return fmt.Sprintf("gcloud compute instances describe %s --zone=%s --project=%s",
		instanceName, zone, projectID)
}

// GcloudSSHInstance returns a gcloud command to SSH into an instance
func GcloudSSHInstance(projectID, zone, instanceName string) string {
	return fmt.Sprintf("gcloud compute ssh %s --zone=%s --project=%s",
		instanceName, zone, projectID)
}

// GsutilList returns a gsutil command to list bucket contents
func GsutilList(bucketName string) string {
	return fmt.Sprintf("gsutil ls -la gs://%s/", bucketName)
}

// GsutilCopy returns a gsutil command to copy from a bucket
func GsutilCopy(bucketName, objectPath, localPath string) string {
	if objectPath == "" {
		return fmt.Sprintf("gsutil -m cp -r gs://%s/* %s", bucketName, localPath)
	}
	return fmt.Sprintf("gsutil cp gs://%s/%s %s", bucketName, objectPath, localPath)
}

// GcloudAccessSecretVersion returns a gcloud command to access a secret
func GcloudAccessSecretVersion(projectID, secretName, version string) string {
	if version == "" {
		version = "latest"
	}
	return fmt.Sprintf("gcloud secrets versions access %s --secret=%s --project=%s",
		version, secretName, projectID)
}

// GcloudListSAKeys returns a gcloud command to list service account keys
func GcloudListSAKeys(projectID, saEmail string) string {
	return fmt.Sprintf("gcloud iam service-accounts keys list --iam-account=%s --project=%s",
		saEmail, projectID)
}

// GcloudCreateSAKey returns a gcloud command to create a service account key
func GcloudCreateSAKey(projectID, saEmail, outputFile string) string {
	return fmt.Sprintf("gcloud iam service-accounts keys create %s --iam-account=%s --project=%s",
		outputFile, saEmail, projectID)
}

// GcloudImpersonateSA returns a gcloud command to impersonate a service account
func GcloudImpersonateSA(saEmail, command string) string {
	return fmt.Sprintf("gcloud %s --impersonate-service-account=%s", command, saEmail)
}

// GcloudGetClusterCredentials returns a gcloud command to get GKE cluster credentials
func GcloudGetClusterCredentials(projectID, location, clusterName string) string {
	locFlag := "--region"
	if !strings.Contains(location, "-") || len(strings.Split(location, "-")) == 3 {
		locFlag = "--zone"
	}
	return fmt.Sprintf("gcloud container clusters get-credentials %s %s=%s --project=%s",
		clusterName, locFlag, location, projectID)
}

// BqQuery returns a bq command to run a query
func BqQuery(projectID, query string) string {
	return fmt.Sprintf("bq query --project_id=%s --use_legacy_sql=false '%s'",
		projectID, query)
}

// BqExtract returns a bq command to extract a table to GCS
func BqExtract(projectID, dataset, table, gcsPath string) string {
	return fmt.Sprintf("bq extract --project_id=%s %s.%s %s",
		projectID, dataset, table, gcsPath)
}
