package commands

import (
	"github.com/BishopFox/cloudfox/gcp/shared"
	"context"
	"fmt"
	"strings"
	"sync"

	notebooksservice "github.com/BishopFox/cloudfox/gcp/services/notebooksService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPNotebooksCommand = &cobra.Command{
	Use:     globals.GCP_NOTEBOOKS_MODULE_NAME,
	Aliases: []string{"nb", "jupyter", "workbench"},
	Short:   "Enumerate Vertex AI Workbench notebooks",
	Long: `Enumerate Vertex AI Workbench and legacy notebook instances.

Features:
- Lists all notebook instances across locations
- Shows service account configuration
- Identifies public IP exposure
- Checks for GPU attachments
- Analyzes proxy access settings`,
	Run: runGCPNotebooksCommand,
}

type NotebooksModule struct {
	gcpinternal.BaseGCPModule
	ProjectInstances map[string][]notebooksservice.NotebookInstanceInfo // projectID -> instances
	ProjectRuntimes  map[string][]notebooksservice.RuntimeInfo          // projectID -> runtimes
	LootMap          map[string]map[string]*internal.LootFile           // projectID -> loot files
	FoxMapperCache   *gcpinternal.FoxMapperCache                        // Cached FoxMapper attack path analysis results
	mu               sync.Mutex
}

type NotebooksOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o NotebooksOutput) TableFiles() []internal.TableFile { return o.Table }
func (o NotebooksOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPNotebooksCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_NOTEBOOKS_MODULE_NAME)
	if err != nil {
		return
	}

	module := &NotebooksModule{
		BaseGCPModule:    gcpinternal.NewBaseGCPModule(cmdCtx),
		ProjectInstances: make(map[string][]notebooksservice.NotebookInstanceInfo),
		ProjectRuntimes:  make(map[string][]notebooksservice.RuntimeInfo),
		LootMap:          make(map[string]map[string]*internal.LootFile),
	}
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *NotebooksModule) Execute(ctx context.Context, logger internal.Logger) {
	// Get FoxMapper cache from context
	m.FoxMapperCache = gcpinternal.GetFoxMapperCacheFromContext(ctx)

	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_NOTEBOOKS_MODULE_NAME, m.processProject)

	allInstances := m.getAllInstances()
	allRuntimes := m.getAllRuntimes()

	if len(allInstances) == 0 && len(allRuntimes) == 0 {
		logger.InfoM("No notebook instances found", globals.GCP_NOTEBOOKS_MODULE_NAME)
		return
	}

	publicCount := 0
	for _, instance := range allInstances {
		if !instance.NoPublicIP {
			publicCount++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d notebook instance(s) (%d with public IP), %d runtime(s)",
		len(allInstances), publicCount, len(allRuntimes)), globals.GCP_NOTEBOOKS_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *NotebooksModule) getAllInstances() []notebooksservice.NotebookInstanceInfo {
	var all []notebooksservice.NotebookInstanceInfo
	for _, instances := range m.ProjectInstances {
		all = append(all, instances...)
	}
	return all
}

func (m *NotebooksModule) getAllRuntimes() []notebooksservice.RuntimeInfo {
	var all []notebooksservice.RuntimeInfo
	for _, runtimes := range m.ProjectRuntimes {
		all = append(all, runtimes...)
	}
	return all
}

func (m *NotebooksModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating notebooks in project: %s", projectID), globals.GCP_NOTEBOOKS_MODULE_NAME)
	}

	svc := notebooksservice.New()

	m.mu.Lock()
	// Initialize loot for this project
	if m.LootMap[projectID] == nil {
		m.LootMap[projectID] = make(map[string]*internal.LootFile)
		m.LootMap[projectID]["notebooks-commands"] = &internal.LootFile{
			Name:     "notebooks-commands",
			Contents: "# Notebook Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
		}
	}
	m.mu.Unlock()

	// Get instances
	instances, err := svc.ListInstances(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_NOTEBOOKS_MODULE_NAME,
			fmt.Sprintf("Could not list notebook instances in project %s", projectID))
	} else {
		m.mu.Lock()
		m.ProjectInstances[projectID] = instances
		for _, instance := range instances {
			m.addToLoot(projectID, instance)
		}
		m.mu.Unlock()
	}

	// Get runtimes (might not be available in all projects)
	runtimes, err := svc.ListRuntimes(projectID)
	if err != nil {
		// Don't increment error counter - runtimes API may not be enabled
		if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
			logger.InfoM(fmt.Sprintf("Could not list runtimes in project %s (may not be enabled)", projectID), globals.GCP_NOTEBOOKS_MODULE_NAME)
		}
	} else {
		m.mu.Lock()
		m.ProjectRuntimes[projectID] = runtimes
		m.mu.Unlock()
	}
}

func (m *NotebooksModule) addToLoot(projectID string, instance notebooksservice.NotebookInstanceInfo) {
	lootFile := m.LootMap[projectID]["notebooks-commands"]
	if lootFile == nil {
		return
	}
	lootFile.Contents += fmt.Sprintf(
		"# =============================================================================\n"+
			"# NOTEBOOK: %s\n"+
			"# =============================================================================\n"+
			"# Project: %s, Location: %s\n"+
			"# State: %s, Service Account: %s\n"+
			"# Public IP: %s, Proxy Access: %s\n",
		instance.Name,
		instance.ProjectID, instance.Location,
		instance.State, instance.ServiceAccount,
		shared.BoolToYesNo(!instance.NoPublicIP), shared.BoolToYesNo(!instance.NoProxyAccess),
	)

	if instance.ProxyUri != "" {
		lootFile.Contents += fmt.Sprintf(
			"# Proxy URI: %s\n", instance.ProxyUri)
	}

	lootFile.Contents += fmt.Sprintf(`
# === ENUMERATION COMMANDS ===

# Describe instance:
gcloud notebooks instances describe %s --location=%s --project=%s

# Get JupyterLab proxy URL:
gcloud notebooks instances describe %s --location=%s --project=%s --format='value(proxyUri)'

# Start instance (if stopped):
gcloud notebooks instances start %s --location=%s --project=%s

# Stop instance:
gcloud notebooks instances stop %s --location=%s --project=%s

# Get instance metadata (service account, network config):
gcloud notebooks instances describe %s --location=%s --project=%s --format=json | jq '{serviceAccount: .serviceAccount, network: .network, subnet: .subnet}'

`,
		instance.Name, instance.Location, instance.ProjectID,
		instance.Name, instance.Location, instance.ProjectID,
		instance.Name, instance.Location, instance.ProjectID,
		instance.Name, instance.Location, instance.ProjectID,
		instance.Name, instance.Location, instance.ProjectID,
	)

	// === EXPLOIT COMMANDS ===
	lootFile.Contents += "# === EXPLOIT COMMANDS ===\n\n"

	// SSH to notebook instance
	if !instance.NoPublicIP {
		lootFile.Contents += fmt.Sprintf(
			"# SSH to notebook instance (runs as SA: %s):\n"+
				"gcloud compute ssh --project=%s --zone=%s notebook-instance-%s\n\n",
			instance.ServiceAccount,
			instance.ProjectID, instance.Location, instance.Name,
		)
	}
	lootFile.Contents += fmt.Sprintf(
		"# SSH through IAP (if direct SSH blocked or no public IP):\n"+
			"gcloud compute ssh notebook-instance-%s --tunnel-through-iap --project=%s --zone=%s\n\n",
		instance.Name, instance.ProjectID, instance.Location,
	)

	// JupyterLab code execution
	if instance.ProxyUri != "" {
		lootFile.Contents += fmt.Sprintf(
			"# Execute code via Jupyter API (runs as SA: %s):\n"+
				"# Access JupyterLab: %s\n\n"+
				"# Create and execute a notebook via Jupyter REST API:\n"+
				"# Step 1: Get Jupyter token (via proxy auth)\n"+
				"# Step 2: Execute arbitrary code:\n"+
				"curl -X POST '%s/api/kernels' -H 'Content-Type: application/json' -d '{\"name\": \"python3\"}'\n\n"+
				"# Execute Python code to steal SA token:\n"+
				"# In JupyterLab terminal or notebook cell:\n"+
				"# import requests\n"+
				"# r = requests.get('http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token', headers={'Metadata-Flavor': 'Google'})\n"+
				"# print(r.json())\n\n",
			instance.ServiceAccount,
			instance.ProxyUri,
			instance.ProxyUri,
		)
	} else {
		lootFile.Contents += fmt.Sprintf(
			"# Start instance to get Jupyter proxy URL, then execute code as SA: %s\n"+
				"gcloud notebooks instances start %s --location=%s --project=%s\n\n",
			instance.ServiceAccount,
			instance.Name, instance.Location, instance.ProjectID,
		)
	}

	// Upload notebook with code execution
	lootFile.Contents += fmt.Sprintf(
		"# Register an instance (Vertex AI Workbench):\n"+
			"gcloud notebooks instances register %s --location=%s --project=%s\n\n",
		instance.Name, instance.Location, instance.ProjectID,
	)
}

func (m *NotebooksModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeHierarchicalOutput(ctx, logger)
	} else {
		m.writeFlatOutput(ctx, logger)
	}
}

func (m *NotebooksModule) getInstancesHeader() []string {
	return []string{
		"Project Name",
		"Project ID",
		"Name",
		"Location",
		"State",
		"Machine Type",
		"Service Account",
		"SA Attack Paths",
		"Network",
		"Subnet",
		"Public IP",
		"Proxy Access",
		"Proxy URI",
		"GPU",
		"Creator",
	}
}

func (m *NotebooksModule) getRuntimesHeader() []string {
	return []string{
		"Project Name",
		"Project ID",
		"Name",
		"Location",
		"State",
		"Type",
		"Machine Type",
		"Service Account",
		"SA Attack Paths",
		"Network",
		"Subnet",
	}
}

func (m *NotebooksModule) instancesToTableBody(instances []notebooksservice.NotebookInstanceInfo) [][]string {
	var body [][]string
	for _, instance := range instances {
		gpu := "-"
		if instance.AcceleratorCount > 0 {
			gpu = fmt.Sprintf("%s x%d", instance.AcceleratorType, instance.AcceleratorCount)
		}
		sa := instance.ServiceAccount
		if sa == "" {
			sa = "(default)"
		}

		// Check attack paths (privesc/exfil/lateral) for the service account
		attackPaths := "run foxmapper"
		if m.FoxMapperCache != nil && m.FoxMapperCache.IsPopulated() {
			if sa != "(default)" && sa != "" {
				attackPaths = gcpinternal.GetAttackSummaryFromCaches(m.FoxMapperCache, nil, sa)
			} else {
				attackPaths = "No"
			}
		}

		network := instance.Network
		if network == "" {
			network = "-"
		}
		subnet := instance.Subnet
		if subnet == "" {
			subnet = "-"
		}
		proxyUri := instance.ProxyUri
		if proxyUri == "" {
			proxyUri = "-"
		}
		creator := instance.Creator
		if creator == "" {
			creator = "-"
		}
		body = append(body, []string{
			m.GetProjectName(instance.ProjectID),
			instance.ProjectID,
			instance.Name,
			instance.Location,
			instance.State,
			instance.MachineType,
			sa,
			attackPaths,
			network,
			subnet,
			shared.BoolToYesNo(!instance.NoPublicIP),
			shared.BoolToYesNo(!instance.NoProxyAccess),
			proxyUri,
			gpu,
			creator,
		})
	}
	return body
}

func (m *NotebooksModule) runtimesToTableBody(runtimes []notebooksservice.RuntimeInfo) [][]string {
	var body [][]string
	for _, runtime := range runtimes {
		sa := runtime.ServiceAccount
		if sa == "" {
			sa = "-"
		}

		// Check attack paths (privesc/exfil/lateral) for the service account
		attackPaths := "run foxmapper"
		if m.FoxMapperCache != nil && m.FoxMapperCache.IsPopulated() {
			if sa != "-" && sa != "" {
				attackPaths = gcpinternal.GetAttackSummaryFromCaches(m.FoxMapperCache, nil, sa)
			} else {
				attackPaths = "No"
			}
		}

		network := runtime.Network
		if network == "" {
			network = "-"
		}
		subnet := runtime.Subnet
		if subnet == "" {
			subnet = "-"
		}
		body = append(body, []string{
			m.GetProjectName(runtime.ProjectID),
			runtime.ProjectID,
			runtime.Name,
			runtime.Location,
			runtime.State,
			runtime.RuntimeType,
			runtime.MachineType,
			sa,
			attackPaths,
			network,
			subnet,
		})
	}
	return body
}

func (m *NotebooksModule) buildTablesForProject(projectID string) []internal.TableFile {
	var tableFiles []internal.TableFile

	if instances, ok := m.ProjectInstances[projectID]; ok && len(instances) > 0 {
		tableFiles = append(tableFiles, internal.TableFile{
			Name:   "notebook-instances",
			Header: m.getInstancesHeader(),
			Body:   m.instancesToTableBody(instances),
		})
	}

	if runtimes, ok := m.ProjectRuntimes[projectID]; ok && len(runtimes) > 0 {
		tableFiles = append(tableFiles, internal.TableFile{
			Name:   "notebook-runtimes",
			Header: m.getRuntimesHeader(),
			Body:   m.runtimesToTableBody(runtimes),
		})
	}

	return tableFiles
}

func (m *NotebooksModule) writeHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	// Get all project IDs that have data
	projectIDs := make(map[string]bool)
	for projectID := range m.ProjectInstances {
		projectIDs[projectID] = true
	}
	for projectID := range m.ProjectRuntimes {
		projectIDs[projectID] = true
	}

	for projectID := range projectIDs {
		tableFiles := m.buildTablesForProject(projectID)

		var lootFiles []internal.LootFile
		if projectLoot, ok := m.LootMap[projectID]; ok {
			for _, loot := range projectLoot {
				if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
					lootFiles = append(lootFiles, *loot)
				}
			}
		}

		outputData.ProjectLevelData[projectID] = NotebooksOutput{Table: tableFiles, Loot: lootFiles}
	}

	pathBuilder := m.BuildPathBuilder()

	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_NOTEBOOKS_MODULE_NAME)
	}
}

func (m *NotebooksModule) writeFlatOutput(ctx context.Context, logger internal.Logger) {
	allInstances := m.getAllInstances()
	allRuntimes := m.getAllRuntimes()

	var tables []internal.TableFile

	if len(allInstances) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "notebook-instances",
			Header: m.getInstancesHeader(),
			Body:   m.instancesToTableBody(allInstances),
		})
	}

	if len(allRuntimes) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "notebook-runtimes",
			Header: m.getRuntimesHeader(),
			Body:   m.runtimesToTableBody(allRuntimes),
		})
	}

	var lootFiles []internal.LootFile
	for _, projectLoot := range m.LootMap {
		for _, loot := range projectLoot {
			if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
				lootFiles = append(lootFiles, *loot)
			}
		}
	}

	output := NotebooksOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart("gcp", m.Format, m.OutputDirectory, m.Verbosity, m.WrapTable,
		"project", m.ProjectIDs, scopeNames, m.Account, output)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_NOTEBOOKS_MODULE_NAME)
	}
}
