package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	logginggapsservice "github.com/BishopFox/cloudfox/gcp/services/loggingGapsService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPLoggingGapsCommand = &cobra.Command{
	Use:     globals.GCP_LOGGINGGAPS_MODULE_NAME,
	Aliases: []string{"log-gaps", "stealth", "blind-spots"},
	Short:   "Find resources with missing or incomplete logging",
	Long: `Identify logging gaps across GCP resources for stealth assessment.

This module helps identify resources where actions may not be properly logged,
which is valuable for understanding detection blind spots.

Resources Checked:
- Cloud Storage buckets (access logging)
- VPC subnets (flow logs)
- GKE clusters (workload and system logging)
- Cloud SQL instances (query and connection logging)
- Log sinks and exclusions (export gaps)
- Project-level audit logging configuration

Output:
- Resources with disabled or partial logging
- Stealth value rating (CRITICAL, HIGH, MEDIUM, LOW)
- Specific missing log types
- Recommendations for defenders
- Commands for testing detection gaps

Stealth Value Ratings:
- CRITICAL: No logging, actions completely invisible
- HIGH: Significant gaps enabling undetected activity
- MEDIUM: Some logging present but incomplete
- LOW: Minor gaps with limited stealth value`,
	Run: runGCPLoggingGapsCommand,
}

// ------------------------------
// Module Struct
// ------------------------------
type LoggingGapsModule struct {
	gcpinternal.BaseGCPModule

	ProjectGaps         map[string][]logginggapsservice.LoggingGap    // projectID -> gaps
	ProjectAuditConfigs map[string]*logginggapsservice.AuditLogConfig // projectID -> audit config
	LootMap             map[string]map[string]*internal.LootFile      // projectID -> loot files
	mu                  sync.Mutex
}

// ------------------------------
// Output Struct
// ------------------------------
type LoggingGapsOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o LoggingGapsOutput) TableFiles() []internal.TableFile { return o.Table }
func (o LoggingGapsOutput) LootFiles() []internal.LootFile   { return o.Loot }

// ------------------------------
// Command Entry Point
// ------------------------------
func runGCPLoggingGapsCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_LOGGINGGAPS_MODULE_NAME)
	if err != nil {
		return
	}

	module := &LoggingGapsModule{
		BaseGCPModule:       gcpinternal.NewBaseGCPModule(cmdCtx),
		ProjectGaps:         make(map[string][]logginggapsservice.LoggingGap),
		ProjectAuditConfigs: make(map[string]*logginggapsservice.AuditLogConfig),
		LootMap:             make(map[string]map[string]*internal.LootFile),
	}

	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

// ------------------------------
// Module Execution
// ------------------------------
func (m *LoggingGapsModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_LOGGINGGAPS_MODULE_NAME, m.processProject)

	allGaps := m.getAllGaps()
	if len(allGaps) == 0 {
		logger.InfoM("No logging gaps found", globals.GCP_LOGGINGGAPS_MODULE_NAME)
		return
	}

	logger.SuccessM(fmt.Sprintf("Found %d logging gap(s)", len(allGaps)), globals.GCP_LOGGINGGAPS_MODULE_NAME)

	m.writeOutput(ctx, logger)
}

func (m *LoggingGapsModule) getAllGaps() []logginggapsservice.LoggingGap {
	var all []logginggapsservice.LoggingGap
	for _, gaps := range m.ProjectGaps {
		all = append(all, gaps...)
	}
	return all
}

// ------------------------------
// Project Processor
// ------------------------------
func (m *LoggingGapsModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Scanning logging gaps in project: %s", projectID), globals.GCP_LOGGINGGAPS_MODULE_NAME)
	}

	m.mu.Lock()
	// Initialize loot for this project
	if m.LootMap[projectID] == nil {
		m.LootMap[projectID] = make(map[string]*internal.LootFile)
		m.LootMap[projectID]["logging-gaps-commands"] = &internal.LootFile{
			Name:     "logging-gaps-commands",
			Contents: "# Logging Gaps Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
		}
	}
	m.mu.Unlock()

	svc := logginggapsservice.New()
	gaps, auditConfig, err := svc.EnumerateLoggingGaps(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_LOGGINGGAPS_MODULE_NAME,
			fmt.Sprintf("Could not enumerate logging gaps in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.ProjectGaps[projectID] = gaps
	if auditConfig != nil {
		m.ProjectAuditConfigs[projectID] = auditConfig
	}

	for _, gap := range gaps {
		m.addGapToLoot(projectID, gap)
	}
	m.mu.Unlock()

	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Found %d logging gap(s) in project %s", len(gaps), projectID), globals.GCP_LOGGINGGAPS_MODULE_NAME)
	}
}

// ------------------------------
// Loot File Management
// ------------------------------
func (m *LoggingGapsModule) addGapToLoot(projectID string, gap logginggapsservice.LoggingGap) {
	lootFile := m.LootMap[projectID]["logging-gaps-commands"]
	if lootFile == nil {
		return
	}
	lootFile.Contents += fmt.Sprintf(
		"## %s: %s (Project: %s, Location: %s)\n"+
			"# Status: %s\n"+
			"# Missing:\n",
		gap.ResourceType, gap.ResourceName,
		gap.ProjectID, gap.Location,
		gap.LoggingStatus,
	)
	for _, missing := range gap.MissingLogs {
		lootFile.Contents += fmt.Sprintf("#   - %s\n", missing)
	}
	lootFile.Contents += "\n"

	// Add exploit commands
	if len(gap.ExploitCommands) > 0 {
		for _, cmd := range gap.ExploitCommands {
			lootFile.Contents += cmd + "\n"
		}
		lootFile.Contents += "\n"
	}
}

// ------------------------------
// Output Generation
// ------------------------------
func (m *LoggingGapsModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeHierarchicalOutput(ctx, logger)
	} else {
		m.writeFlatOutput(ctx, logger)
	}
}

func (m *LoggingGapsModule) getHeader() []string {
	return []string{
		"Project ID",
		"Project Name",
		"Type",
		"Resource",
		"Location",
		"Status",
		"Missing Logs",
	}
}

func (m *LoggingGapsModule) gapsToTableBody(gaps []logginggapsservice.LoggingGap) [][]string {
	var body [][]string
	for _, gap := range gaps {
		missingLogs := strings.Join(gap.MissingLogs, "; ")

		location := gap.Location
		if location == "" {
			location = "-"
		}

		body = append(body, []string{
			gap.ProjectID,
			m.GetProjectName(gap.ProjectID),
			gap.ResourceType,
			gap.ResourceName,
			location,
			gap.LoggingStatus,
			missingLogs,
		})
	}
	return body
}

func (m *LoggingGapsModule) buildTablesForProject(projectID string) []internal.TableFile {
	var tableFiles []internal.TableFile

	if gaps, ok := m.ProjectGaps[projectID]; ok && len(gaps) > 0 {
		tableFiles = append(tableFiles, internal.TableFile{
			Name:   "logging-gaps",
			Header: m.getHeader(),
			Body:   m.gapsToTableBody(gaps),
		})
	}

	return tableFiles
}

func (m *LoggingGapsModule) writeHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	for projectID := range m.ProjectGaps {
		tableFiles := m.buildTablesForProject(projectID)

		var lootFiles []internal.LootFile
		if projectLoot, ok := m.LootMap[projectID]; ok {
			for _, loot := range projectLoot {
				if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
					lootFiles = append(lootFiles, *loot)
				}
			}
		}

		outputData.ProjectLevelData[projectID] = LoggingGapsOutput{Table: tableFiles, Loot: lootFiles}
	}

	pathBuilder := m.BuildPathBuilder()

	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_LOGGINGGAPS_MODULE_NAME)
	}
}

func (m *LoggingGapsModule) writeFlatOutput(ctx context.Context, logger internal.Logger) {
	allGaps := m.getAllGaps()

	var tables []internal.TableFile

	if len(allGaps) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "logging-gaps",
			Header: m.getHeader(),
			Body:   m.gapsToTableBody(allGaps),
		})
	}

	var lootFiles []internal.LootFile
	for _, projectLoot := range m.LootMap {
		for _, loot := range projectLoot {
			if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
				lootFiles = append(lootFiles, *loot)
			}
		}
	}

	output := LoggingGapsOutput{
		Table: tables,
		Loot:  lootFiles,
	}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		m.ProjectIDs,
		scopeNames,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_LOGGINGGAPS_MODULE_NAME)
		m.CommandCounter.Error++
	}
}
