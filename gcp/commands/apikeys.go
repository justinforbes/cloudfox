package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"

	apikeysservice "github.com/BishopFox/cloudfox/gcp/services/apikeysService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPAPIKeysCommand = &cobra.Command{
	Use:     globals.GCP_APIKEYS_MODULE_NAME,
	Aliases: []string{"api-keys", "keys"},
	Short:   "Enumerate GCP API keys with security analysis",
	Long: `Enumerate GCP API keys with detailed security analysis.

Features:
- Lists all API keys in the project
- Analyzes key restrictions (API, IP, referer, app)
- Retrieves key strings (if permissions allow)
- Identifies unrestricted or weakly restricted keys
- Flags old keys without rotation
- Shows API targets and access patterns
- Generates commands for testing key access`,
	Run: runGCPAPIKeysCommand,
}

// ------------------------------
// Module Struct with embedded BaseGCPModule
// ------------------------------
type APIKeysModule struct {
	gcpinternal.BaseGCPModule

	// Module-specific fields
	APIKeys []apikeysservice.APIKeyInfo
	LootMap map[string]*internal.LootFile
	mu      sync.Mutex
}

// ------------------------------
// Output Struct implementing CloudfoxOutput interface
// ------------------------------
type APIKeysOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o APIKeysOutput) TableFiles() []internal.TableFile { return o.Table }
func (o APIKeysOutput) LootFiles() []internal.LootFile   { return o.Loot }

// ------------------------------
// Command Entry Point
// ------------------------------
func runGCPAPIKeysCommand(cmd *cobra.Command, args []string) {
	// Initialize command context
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_APIKEYS_MODULE_NAME)
	if err != nil {
		return // Error already logged
	}

	// Create module instance
	module := &APIKeysModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		APIKeys:       []apikeysservice.APIKeyInfo{},
		LootMap:       make(map[string]*internal.LootFile),
	}

	// Initialize loot files
	module.initializeLootFiles()

	// Execute enumeration
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

// ------------------------------
// Module Execution
// ------------------------------
func (m *APIKeysModule) Execute(ctx context.Context, logger internal.Logger) {
	// Run enumeration with concurrency
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_APIKEYS_MODULE_NAME, m.processProject)

	// Check results
	if len(m.APIKeys) == 0 {
		logger.InfoM("No API keys found", globals.GCP_APIKEYS_MODULE_NAME)
		return
	}

	// Count findings
	unrestricted := 0
	highRisk := 0
	withKeyStrings := 0
	for _, key := range m.APIKeys {
		if key.IsUnrestricted {
			unrestricted++
		}
		if key.RiskLevel == "HIGH" {
			highRisk++
		}
		if key.KeyString != "" {
			withKeyStrings++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d API key(s) (%d unrestricted, %d high-risk, %d with key strings)",
		len(m.APIKeys), unrestricted, highRisk, withKeyStrings), globals.GCP_APIKEYS_MODULE_NAME)

	// Write output
	m.writeOutput(ctx, logger)
}

// ------------------------------
// Project Processor (called concurrently for each project)
// ------------------------------
func (m *APIKeysModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating API keys in project: %s", projectID), globals.GCP_APIKEYS_MODULE_NAME)
	}

	// Create service and fetch API keys
	service := apikeysservice.New()
	keys, err := service.ListAPIKeysWithKeyStrings(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_APIKEYS_MODULE_NAME,
			fmt.Sprintf("Could not enumerate API keys in project %s", projectID))
		return
	}

	// Thread-safe append
	m.mu.Lock()
	m.APIKeys = append(m.APIKeys, keys...)

	// Generate loot for each API key
	for _, key := range keys {
		m.addAPIKeyToLoot(key)
	}
	m.mu.Unlock()

	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Found %d API key(s) in project %s", len(keys), projectID), globals.GCP_APIKEYS_MODULE_NAME)
	}
}

// ------------------------------
// Loot File Management
// ------------------------------
func (m *APIKeysModule) initializeLootFiles() {
	m.LootMap["apikeys-all"] = &internal.LootFile{
		Name:     "apikeys-all",
		Contents: "# All API Keys\n# Generated by CloudFox\n# Format: key_string|project|name|restrictions\n\n",
	}
	m.LootMap["apikeys-unrestricted"] = &internal.LootFile{
		Name:     "apikeys-unrestricted",
		Contents: "# Unrestricted API Keys\n# Generated by CloudFox\n# WARNING: These keys have no restrictions!\n\n",
	}
	m.LootMap["apikeys-high-risk"] = &internal.LootFile{
		Name:     "apikeys-high-risk",
		Contents: "# High-Risk API Keys\n# Generated by CloudFox\n\n",
	}
	m.LootMap["apikeys-test-commands"] = &internal.LootFile{
		Name:     "apikeys-test-commands",
		Contents: "# API Key Test Commands\n# Generated by CloudFox\n# Use these to verify key access\n\n",
	}
	m.LootMap["apikeys-key-strings"] = &internal.LootFile{
		Name:     "apikeys-key-strings",
		Contents: "",
	}
}

func (m *APIKeysModule) addAPIKeyToLoot(key apikeysservice.APIKeyInfo) {
	// Extract key ID from full name
	keyID := extractKeyID(key.Name)

	// Key string file (just the values)
	if key.KeyString != "" {
		m.LootMap["apikeys-key-strings"].Contents += key.KeyString + "\n"
	}

	// All keys with details
	restrictions := "unrestricted"
	if key.HasRestrictions {
		restrictions = key.RestrictionType
		if len(key.AllowedAPIs) > 0 {
			restrictions += fmt.Sprintf(" (APIs: %s)", strings.Join(key.AllowedAPIs, ", "))
		}
	}
	m.LootMap["apikeys-all"].Contents += fmt.Sprintf(
		"# Key: %s\n"+
			"# Project: %s\n"+
			"# Display Name: %s\n"+
			"# Restrictions: %s\n"+
			"# Risk Level: %s\n",
		keyID,
		key.ProjectID,
		key.DisplayName,
		restrictions,
		key.RiskLevel,
	)
	if key.KeyString != "" {
		m.LootMap["apikeys-all"].Contents += fmt.Sprintf("KEY_STRING=%s\n", key.KeyString)
	}
	m.LootMap["apikeys-all"].Contents += "\n"

	// Unrestricted keys
	if key.IsUnrestricted {
		m.LootMap["apikeys-unrestricted"].Contents += fmt.Sprintf(
			"# Key: %s\n"+
				"# Project: %s\n"+
				"# Display Name: %s\n"+
				"# Created: %s\n",
			keyID,
			key.ProjectID,
			key.DisplayName,
			key.CreateTime.Format("2006-01-02"),
		)
		if key.KeyString != "" {
			m.LootMap["apikeys-unrestricted"].Contents += fmt.Sprintf("KEY_STRING=%s\n", key.KeyString)
		}
		m.LootMap["apikeys-unrestricted"].Contents += "\n"
	}

	// High-risk keys
	if key.RiskLevel == "HIGH" {
		m.LootMap["apikeys-high-risk"].Contents += fmt.Sprintf(
			"# Key: %s\n"+
				"# Project: %s\n"+
				"# Risk Level: %s\n"+
				"# Reasons:\n",
			keyID,
			key.ProjectID,
			key.RiskLevel,
		)
		for _, reason := range key.RiskReasons {
			m.LootMap["apikeys-high-risk"].Contents += fmt.Sprintf("  - %s\n", reason)
		}
		if key.KeyString != "" {
			m.LootMap["apikeys-high-risk"].Contents += fmt.Sprintf("KEY_STRING=%s\n", key.KeyString)
		}
		m.LootMap["apikeys-high-risk"].Contents += "\n"
	}

	// Test commands
	if key.KeyString != "" {
		m.LootMap["apikeys-test-commands"].Contents += fmt.Sprintf(
			"# Test key: %s (Project: %s)\n"+
				"# Try accessing various APIs with this key:\n"+
				"curl -H 'X-Goog-Api-Key: %s' 'https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway'\n"+
				"curl -H 'X-Goog-Api-Key: %s' 'https://translation.googleapis.com/language/translate/v2?q=Hello&target=es'\n"+
				"curl -H 'X-Goog-Api-Key: %s' 'https://www.googleapis.com/customsearch/v1?q=test'\n\n",
			keyID,
			key.ProjectID,
			key.KeyString,
			key.KeyString,
			key.KeyString,
		)
	}
}

// extractKeyID extracts the key ID from the full resource name
func extractKeyID(name string) string {
	parts := strings.Split(name, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return name
}

// ------------------------------
// Output Generation
// ------------------------------
func (m *APIKeysModule) writeOutput(ctx context.Context, logger internal.Logger) {
	// Main API keys table
	keysHeader := []string{
		"Key ID",
		"Display Name",
		"Project Name",
		"Project",
		"Restriction Type",
		"API Targets",
		"Age (days)",
		"Risk",
		"Has Key String",
	}

	var keysBody [][]string
	for _, key := range m.APIKeys {
		keyID := extractKeyID(key.Name)

		restrictionType := key.RestrictionType
		if restrictionType == "" {
			restrictionType = "none"
		}

		apiTargets := "-"
		if len(key.AllowedAPIs) > 0 {
			if len(key.AllowedAPIs) > 2 {
				apiTargets = fmt.Sprintf("%s +%d more", strings.Join(key.AllowedAPIs[:2], ", "), len(key.AllowedAPIs)-2)
			} else {
				apiTargets = strings.Join(key.AllowedAPIs, ", ")
			}
		}

		age := "-"
		if !key.CreateTime.IsZero() {
			age = fmt.Sprintf("%d", int(time.Since(key.CreateTime).Hours()/24))
		}

		hasKeyString := "No"
		if key.KeyString != "" {
			hasKeyString = "Yes"
		}

		keysBody = append(keysBody, []string{
			keyID,
			key.DisplayName,
			m.GetProjectName(key.ProjectID),
			key.ProjectID,
			restrictionType,
			apiTargets,
			age,
			key.RiskLevel,
			hasKeyString,
		})
	}

	// Unrestricted keys table
	unrestrictedHeader := []string{
		"Key ID",
		"Display Name",
		"Project Name",
		"Project",
		"Created",
		"Has Key String",
	}

	var unrestrictedBody [][]string
	for _, key := range m.APIKeys {
		if key.IsUnrestricted {
			keyID := extractKeyID(key.Name)
			created := "-"
			if !key.CreateTime.IsZero() {
				created = key.CreateTime.Format("2006-01-02")
			}
			hasKeyString := "No"
			if key.KeyString != "" {
				hasKeyString = "Yes"
			}

			unrestrictedBody = append(unrestrictedBody, []string{
				keyID,
				key.DisplayName,
				m.GetProjectName(key.ProjectID),
				key.ProjectID,
				created,
				hasKeyString,
			})
		}
	}

	// Restrictions detail table
	restrictionsHeader := []string{
		"Key ID",
		"Project Name",
		"Project",
		"Type",
		"Allowed Values",
	}

	var restrictionsBody [][]string
	for _, key := range m.APIKeys {
		if key.HasRestrictions {
			keyID := extractKeyID(key.Name)

			// Add API restrictions
			if len(key.AllowedAPIs) > 0 {
				restrictionsBody = append(restrictionsBody, []string{
					keyID,
					m.GetProjectName(key.ProjectID),
					key.ProjectID,
					"API",
					strings.Join(key.AllowedAPIs, ", "),
				})
			}

			// Add referer restrictions
			if len(key.AllowedReferers) > 0 {
				restrictionsBody = append(restrictionsBody, []string{
					keyID,
					m.GetProjectName(key.ProjectID),
					key.ProjectID,
					"Referer",
					strings.Join(key.AllowedReferers, ", "),
				})
			}

			// Add IP restrictions
			if len(key.AllowedIPs) > 0 {
				restrictionsBody = append(restrictionsBody, []string{
					keyID,
					m.GetProjectName(key.ProjectID),
					key.ProjectID,
					"IP",
					strings.Join(key.AllowedIPs, ", "),
				})
			}

			// Add Android app restrictions
			if len(key.AllowedAndroidApps) > 0 {
				restrictionsBody = append(restrictionsBody, []string{
					keyID,
					m.GetProjectName(key.ProjectID),
					key.ProjectID,
					"Android",
					strings.Join(key.AllowedAndroidApps, ", "),
				})
			}

			// Add iOS app restrictions
			if len(key.AllowedIOSApps) > 0 {
				restrictionsBody = append(restrictionsBody, []string{
					keyID,
					m.GetProjectName(key.ProjectID),
					key.ProjectID,
					"iOS",
					strings.Join(key.AllowedIOSApps, ", "),
				})
			}
		}
	}

	// High-risk keys table
	highRiskHeader := []string{
		"Key ID",
		"Project Name",
		"Project",
		"Risk Level",
		"Risk Reasons",
	}

	var highRiskBody [][]string
	for _, key := range m.APIKeys {
		if key.RiskLevel == "HIGH" || key.RiskLevel == "MEDIUM" {
			keyID := extractKeyID(key.Name)
			highRiskBody = append(highRiskBody, []string{
				keyID,
				m.GetProjectName(key.ProjectID),
				key.ProjectID,
				key.RiskLevel,
				strings.Join(key.RiskReasons, "; "),
			})
		}
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# Generated by CloudFox\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	// Build tables
	tables := []internal.TableFile{
		{
			Name:   "apikeys",
			Header: keysHeader,
			Body:   keysBody,
		},
	}

	// Add unrestricted keys table if there are any
	if len(unrestrictedBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "apikeys-unrestricted",
			Header: unrestrictedHeader,
			Body:   unrestrictedBody,
		})
		logger.InfoM(fmt.Sprintf("[FINDING] Found %d unrestricted API key(s)!", len(unrestrictedBody)), globals.GCP_APIKEYS_MODULE_NAME)
	}

	// Add restrictions table if there are any
	if len(restrictionsBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "apikeys-restrictions",
			Header: restrictionsHeader,
			Body:   restrictionsBody,
		})
	}

	// Add high-risk table if there are any
	if len(highRiskBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "apikeys-high-risk",
			Header: highRiskHeader,
			Body:   highRiskBody,
		})
		logger.InfoM(fmt.Sprintf("[FINDING] Found %d high/medium risk API key(s)", len(highRiskBody)), globals.GCP_APIKEYS_MODULE_NAME)
	}

	output := APIKeysOutput{
		Table: tables,
		Loot:  lootFiles,
	}

	// Write output using HandleOutputSmart with scope support
	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}
	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",           // scopeType
		m.ProjectIDs,        // scopeIdentifiers
		scopeNames,          // scopeNames
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_APIKEYS_MODULE_NAME)
		m.CommandCounter.Error++
	}
}
