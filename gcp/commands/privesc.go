package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	foxmapperservice "github.com/BishopFox/cloudfox/gcp/services/foxmapperService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPPrivescCommand = &cobra.Command{
	Use:     globals.GCP_PRIVESC_MODULE_NAME,
	Aliases: []string{"pe", "escalate", "priv"},
	Short:   "Identify privilege escalation paths in GCP organizations, folders, and projects",
	Long: `Analyze FoxMapper graph data to identify privilege escalation opportunities.

This module uses FoxMapper's graph-based analysis to find principals with paths
to admin-level access within the GCP environment.

Prerequisites:
- Run 'foxmapper gcp graph create' first to generate the graph data

Features:
- Identifies principals with privilege escalation paths to admin
- Shows shortest paths to organization, folder, and project admins
- Detects scope-limited paths (OAuth scope restrictions)
- Generates exploitation playbooks

Detected privilege escalation vectors include:
- Service Account Token Creation (getAccessToken, getOpenIdToken)
- Service Account Key Creation (serviceAccountKeys.create)
- IAM Policy Modification (setIamPolicy)
- Compute Instance Creation with privileged SA
- Cloud Functions/Run deployment with SA
- And 60+ more techniques

Run 'foxmapper gcp graph create' to generate the graph, then use this module.`,
	Run: runGCPPrivescCommand,
}

type PrivescModule struct {
	gcpinternal.BaseGCPModule

	// FoxMapper data
	FoxMapperCache *gcpinternal.FoxMapperCache
	Findings       []foxmapperservice.PrivescFinding

	// Loot
	LootMap map[string]*internal.LootFile
	mu      sync.Mutex
}

type PrivescOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o PrivescOutput) TableFiles() []internal.TableFile { return o.Table }
func (o PrivescOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPPrivescCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_PRIVESC_MODULE_NAME)
	if err != nil {
		return
	}

	module := &PrivescModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Findings:      []foxmapperservice.PrivescFinding{},
		LootMap:       make(map[string]*internal.LootFile),
	}
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *PrivescModule) Execute(ctx context.Context, logger internal.Logger) {
	logger.InfoM("Analyzing privilege escalation paths using FoxMapper...", globals.GCP_PRIVESC_MODULE_NAME)

	// Get FoxMapper cache from context or try to load it
	m.FoxMapperCache = gcpinternal.GetFoxMapperCacheFromContext(ctx)
	if m.FoxMapperCache == nil || !m.FoxMapperCache.IsPopulated() {
		// Try to load FoxMapper data (org from hierarchy if available)
		orgID := ""
		if m.Hierarchy != nil && len(m.Hierarchy.Organizations) > 0 {
			orgID = m.Hierarchy.Organizations[0].ID
		}
		m.FoxMapperCache = gcpinternal.TryLoadFoxMapper(orgID, m.ProjectIDs)
	}

	if m.FoxMapperCache == nil || !m.FoxMapperCache.IsPopulated() {
		logger.ErrorM("No FoxMapper data found. Run 'foxmapper gcp graph create' first.", globals.GCP_PRIVESC_MODULE_NAME)
		logger.InfoM("FoxMapper creates a graph of IAM relationships for accurate privesc analysis.", globals.GCP_PRIVESC_MODULE_NAME)
		return
	}

	// Get the FoxMapper service and analyze privesc
	svc := m.FoxMapperCache.GetService()
	m.Findings = svc.AnalyzePrivesc()

	// Generate loot
	m.generateLoot()

	if len(m.Findings) == 0 {
		logger.InfoM("No privilege escalation paths found", globals.GCP_PRIVESC_MODULE_NAME)
		return
	}

	// Count statistics
	adminCount := 0
	privescCount := 0
	orgReachable := 0
	folderReachable := 0
	projectReachable := 0

	for _, f := range m.Findings {
		if f.IsAdmin {
			adminCount++
		} else if f.CanEscalate {
			privescCount++
			if f.PathsToOrgAdmin > 0 {
				orgReachable++
			}
			if f.PathsToFolderAdmin > 0 {
				folderReachable++
			}
			if f.PathsToProjectAdmin > 0 {
				projectReachable++
			}
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d admin(s) and %d principal(s) with privilege escalation paths",
		adminCount, privescCount), globals.GCP_PRIVESC_MODULE_NAME)

	if privescCount > 0 {
		logger.InfoM(fmt.Sprintf("  → %d can reach org admin, %d folder admin, %d project admin",
			orgReachable, folderReachable, projectReachable), globals.GCP_PRIVESC_MODULE_NAME)
	}

	m.writeOutput(ctx, logger)
}

func (m *PrivescModule) generateLoot() {
	m.LootMap["privesc-exploit-commands"] = &internal.LootFile{
		Name:     "privesc-exploit-commands",
		Contents: "# GCP Privilege Escalation Exploit Commands\n# Generated by CloudFox using FoxMapper graph data\n\n",
	}

	// Generate playbook
	m.generatePlaybook()
}

func (m *PrivescModule) generatePlaybook() {
	var sb strings.Builder
	sb.WriteString("# GCP Privilege Escalation Playbook\n")
	sb.WriteString("# Generated by CloudFox using FoxMapper graph data\n\n")

	// Group findings by admin level reachable
	orgPaths := []foxmapperservice.PrivescFinding{}
	folderPaths := []foxmapperservice.PrivescFinding{}
	projectPaths := []foxmapperservice.PrivescFinding{}

	for _, f := range m.Findings {
		if f.IsAdmin {
			continue // Skip admins in playbook
		}
		if !f.CanEscalate {
			continue
		}

		switch f.HighestAdminLevel {
		case "org":
			orgPaths = append(orgPaths, f)
		case "folder":
			folderPaths = append(folderPaths, f)
		case "project":
			projectPaths = append(projectPaths, f)
		}
	}

	// Organization-level privesc (highest priority)
	if len(orgPaths) > 0 {
		sb.WriteString("## CRITICAL: Organization Admin Reachable\n\n")
		for _, f := range orgPaths {
			m.writePrivescFindingToPlaybook(&sb, f)
		}
	}

	// Folder-level privesc
	if len(folderPaths) > 0 {
		sb.WriteString("## HIGH: Folder Admin Reachable\n\n")
		for _, f := range folderPaths {
			m.writePrivescFindingToPlaybook(&sb, f)
		}
	}

	// Project-level privesc
	if len(projectPaths) > 0 {
		sb.WriteString("## MEDIUM: Project Admin Reachable\n\n")
		for _, f := range projectPaths {
			m.writePrivescFindingToPlaybook(&sb, f)
		}
	}

	m.LootMap["privesc-playbook"] = &internal.LootFile{
		Name:     "privesc-playbook",
		Contents: sb.String(),
	}
}

// writePrivescFindingToPlaybook writes a detailed privesc finding to the playbook
func (m *PrivescModule) writePrivescFindingToPlaybook(sb *strings.Builder, f foxmapperservice.PrivescFinding) {
	sb.WriteString(fmt.Sprintf("### %s\n", f.Principal))
	sb.WriteString(fmt.Sprintf("- **Type**: %s\n", f.MemberType))
	sb.WriteString(fmt.Sprintf("- **Shortest path**: %d hops\n", f.ShortestPathHops))
	sb.WriteString(fmt.Sprintf("- **Viable paths**: %d\n", f.ViablePathCount))
	if f.ScopeBlockedCount > 0 {
		sb.WriteString(fmt.Sprintf("- **Scope-blocked paths**: %d (OAuth scope restrictions)\n", f.ScopeBlockedCount))
	}
	sb.WriteString("\n")

	// Show all paths with detailed steps
	if len(f.Paths) > 0 {
		sb.WriteString("#### Attack Paths\n\n")
		for pathIdx, path := range f.Paths {
			// Limit to top 5 paths per principal to avoid excessive output
			if pathIdx >= 5 {
				sb.WriteString(fmt.Sprintf("*... and %d more paths*\n\n", len(f.Paths)-5))
				break
			}

			scopeStatus := ""
			if path.ScopeBlocked {
				scopeStatus = " ⚠️ SCOPE-BLOCKED"
			}

			sb.WriteString(fmt.Sprintf("**Path %d** → %s (%s admin, %d hops)%s\n",
				pathIdx+1, path.Destination, path.AdminLevel, path.HopCount, scopeStatus))
			sb.WriteString("```\n")
			sb.WriteString(fmt.Sprintf("%s\n", f.Principal))

			for i, edge := range path.Edges {
				// Show the hop number and technique
				prefix := "  │"
				if i == len(path.Edges)-1 {
					prefix = "  └"
				}

				scopeWarning := ""
				if edge.ScopeBlocksEscalation {
					scopeWarning = " [BLOCKED BY SCOPE]"
				} else if edge.ScopeLimited {
					scopeWarning = " [scope-limited]"
				}

				sb.WriteString(fmt.Sprintf("%s── (%d) %s%s\n", prefix, i+1, edge.ShortReason, scopeWarning))

				// Show destination after each hop
				if edge.Destination != "" {
					destDisplay := edge.Destination
					// Clean up member ID format for display
					if strings.HasPrefix(destDisplay, "serviceAccount:") {
						destDisplay = strings.TrimPrefix(destDisplay, "serviceAccount:")
					} else if strings.HasPrefix(destDisplay, "user:") {
						destDisplay = strings.TrimPrefix(destDisplay, "user:")
					}
					if i == len(path.Edges)-1 {
						sb.WriteString(fmt.Sprintf("      → %s (ADMIN)\n", destDisplay))
					} else {
						sb.WriteString(fmt.Sprintf("  │   → %s\n", destDisplay))
					}
				}
			}
			sb.WriteString("```\n\n")

			// Show detailed exploitation steps
			if !path.ScopeBlocked && len(path.Edges) > 0 {
				sb.WriteString("**Exploitation steps:**\n")
				for i, edge := range path.Edges {
					sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, edge.Reason))
				}
				sb.WriteString("\n")
			}
		}
	}
	sb.WriteString("---\n\n")
}

func (m *PrivescModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeHierarchicalOutput(ctx, logger)
	} else {
		m.writeFlatOutput(ctx, logger)
	}
}

func (m *PrivescModule) getHeader() []string {
	return []string{
		"Principal",
		"Type",
		"Is Admin",
		"Admin Level",
		"Can Escalate",
		"Highest Reachable",
		"Path Summary",
		"Hops",
		"Viable Paths",
		"Scope Blocked",
	}
}

func (m *PrivescModule) findingsToTableBody() [][]string {
	var body [][]string
	for _, f := range m.Findings {
		isAdmin := "No"
		if f.IsAdmin {
			isAdmin = "Yes"
		}

		adminLevel := f.HighestAdminLevel
		if adminLevel == "" {
			adminLevel = "-"
		}

		canEscalate := "No"
		if f.CanEscalate {
			canEscalate = "Yes"
		}

		highestReachable := "-"
		if f.CanEscalate || f.IsAdmin {
			highestReachable = f.HighestAdminLevel
		}

		// Build path summary showing cross-project or internal escalation
		pathSummary := "-"
		if f.CanEscalate && len(f.Paths) > 0 {
			pathSummary = m.buildPathSummary(f)
		}

		hops := "-"
		if f.ShortestPathHops > 0 {
			hops = fmt.Sprintf("%d", f.ShortestPathHops)
		}

		viablePaths := "-"
		if f.ViablePathCount > 0 {
			viablePaths = fmt.Sprintf("%d", f.ViablePathCount)
		}

		scopeBlocked := "-"
		if f.ScopeBlockedCount > 0 {
			scopeBlocked = fmt.Sprintf("%d", f.ScopeBlockedCount)
		}

		body = append(body, []string{
			f.Principal,
			f.MemberType,
			isAdmin,
			adminLevel,
			canEscalate,
			highestReachable,
			pathSummary,
			hops,
			viablePaths,
			scopeBlocked,
		})
	}
	return body
}

// buildPathSummary creates a summary showing the escalation path type
// e.g., "proj-a → proj-b (cross-project)" or "proj-a (internal)"
func (m *PrivescModule) buildPathSummary(f foxmapperservice.PrivescFinding) string {
	// Extract source project from principal email
	sourceProject := extractProjectFromPrincipal(f.Principal)

	// Get destination project from the best path
	destProject := f.HighestReachableProject

	// If we couldn't determine projects, show a simple summary
	if sourceProject == "" && destProject == "" {
		return fmt.Sprintf("→ %s admin", f.HighestAdminLevel)
	}

	// Handle org/folder level escalation
	if f.HighestAdminLevel == "org" {
		if sourceProject != "" {
			return fmt.Sprintf("%s → org", sourceProject)
		}
		return "→ org"
	}

	if f.HighestAdminLevel == "folder" {
		if sourceProject != "" {
			return fmt.Sprintf("%s → folder", sourceProject)
		}
		return "→ folder"
	}

	// Project-level escalation
	if sourceProject == "" {
		sourceProject = "?"
	}
	if destProject == "" {
		destProject = "?"
	}

	if sourceProject == destProject {
		return fmt.Sprintf("%s (internal)", sourceProject)
	}

	return fmt.Sprintf("%s → %s", sourceProject, destProject)
}

// extractProjectFromPrincipal extracts project ID from a service account email
// e.g., "sa@my-project.iam.gserviceaccount.com" -> "my-project"
func extractProjectFromPrincipal(principal string) string {
	// Handle service account format: name@project.iam.gserviceaccount.com
	if strings.Contains(principal, ".iam.gserviceaccount.com") {
		parts := strings.Split(principal, "@")
		if len(parts) == 2 {
			domain := parts[1]
			projectPart := strings.TrimSuffix(domain, ".iam.gserviceaccount.com")
			return projectPart
		}
	}

	// Handle compute default SA: project-number-compute@developer.gserviceaccount.com
	if strings.Contains(principal, "-compute@developer.gserviceaccount.com") {
		// Can't easily get project name from number, return empty
		return ""
	}

	// Handle App Engine default SA: project@appspot.gserviceaccount.com
	if strings.Contains(principal, "@appspot.gserviceaccount.com") {
		parts := strings.Split(principal, "@")
		if len(parts) == 2 {
			return strings.TrimSuffix(parts[0], "")
		}
	}

	return ""
}

func (m *PrivescModule) buildAllTables() []internal.TableFile {
	if len(m.Findings) == 0 {
		return nil
	}
	return []internal.TableFile{
		{
			Name:   "privesc",
			Header: m.getHeader(),
			Body:   m.findingsToTableBody(),
		},
	}
}

func (m *PrivescModule) collectLootFiles() []internal.LootFile {
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# Generated by CloudFox using FoxMapper graph data\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}
	return lootFiles
}

func (m *PrivescModule) writeHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	// Determine scope - use org if available, otherwise first project
	scopeID := ""
	if m.Hierarchy != nil && len(m.Hierarchy.Organizations) > 0 {
		scopeID = m.Hierarchy.Organizations[0].ID
	} else if len(m.ProjectIDs) > 0 {
		scopeID = m.ProjectIDs[0]
	}

	if scopeID != "" {
		tables := m.buildAllTables()
		lootFiles := m.collectLootFiles()

		// Use org level data if we have org scope
		if m.Hierarchy != nil && len(m.Hierarchy.Organizations) > 0 {
			outputData.OrgLevelData[scopeID] = PrivescOutput{Table: tables, Loot: lootFiles}
		} else {
			outputData.ProjectLevelData[scopeID] = PrivescOutput{Table: tables, Loot: lootFiles}
		}
	}

	pathBuilder := m.BuildPathBuilder()

	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_PRIVESC_MODULE_NAME)
	}
}

func (m *PrivescModule) writeFlatOutput(ctx context.Context, logger internal.Logger) {
	tables := m.buildAllTables()
	lootFiles := m.collectLootFiles()

	output := PrivescOutput{Table: tables, Loot: lootFiles}

	// Determine output scope
	var scopeType string
	var scopeIdentifiers []string
	var scopeNames []string

	if m.Hierarchy != nil && len(m.Hierarchy.Organizations) > 0 {
		scopeType = "organization"
		scopeIdentifiers = []string{m.Hierarchy.Organizations[0].ID}
		scopeNames = []string{m.Hierarchy.Organizations[0].DisplayName}
	} else {
		scopeType = "project"
		scopeIdentifiers = m.ProjectIDs
		for _, id := range m.ProjectIDs {
			scopeNames = append(scopeNames, m.GetProjectName(id))
		}
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		scopeType,
		scopeIdentifiers,
		scopeNames,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_PRIVESC_MODULE_NAME)
	}
}
