package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	privescservice "github.com/BishopFox/cloudfox/gcp/services/privescService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPPrivescCommand = &cobra.Command{
	Use:     globals.GCP_PRIVESC_MODULE_NAME,
	Aliases: []string{"pe", "escalate", "priv"},
	Short:   "Identify privilege escalation paths in GCP projects",
	Long: `Analyze GCP IAM policies to identify privilege escalation opportunities.

This module examines IAM bindings to find principals with dangerous permissions
that could be used to escalate privileges within the GCP environment.

Detected privilege escalation methods include:
- Service Account Token Creation (iam.serviceAccounts.getAccessToken)
- Service Account Key Creation (iam.serviceAccountKeys.create)
- Project/Folder/Org IAM Policy Modification
- Compute Instance Metadata Injection (SSH keys, startup scripts)
- Cloud Functions/Run Deployment with SA Identity
- Cloud Build SA Abuse
- GKE Cluster Access
- Secret Manager Access
- Signed URL/JWT Generation

Risk Levels:
- CRITICAL: Direct path to project/org compromise
- HIGH: Can escalate to privileged service account
- MEDIUM: Can access sensitive resources`,
	Run: runGCPPrivescCommand,
}

type PrivescModule struct {
	gcpinternal.BaseGCPModule
	Paths   []privescservice.PrivescPath
	LootMap map[string]*internal.LootFile
	mu      sync.Mutex
}

type PrivescOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o PrivescOutput) TableFiles() []internal.TableFile { return o.Table }
func (o PrivescOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPPrivescCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_PRIVESC_MODULE_NAME)
	if err != nil {
		return
	}

	module := &PrivescModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Paths:         []privescservice.PrivescPath{},
		LootMap:       make(map[string]*internal.LootFile),
	}
	module.initializeLootFiles()
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *PrivescModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_PRIVESC_MODULE_NAME, m.processProject)

	if len(m.Paths) == 0 {
		logger.InfoM("No privilege escalation paths found", globals.GCP_PRIVESC_MODULE_NAME)
		return
	}

	// Count by risk level
	criticalCount := 0
	highCount := 0
	for _, path := range m.Paths {
		switch path.RiskLevel {
		case "CRITICAL":
			criticalCount++
		case "HIGH":
			highCount++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d privilege escalation path(s) (%d CRITICAL, %d HIGH)",
		len(m.Paths), criticalCount, highCount), globals.GCP_PRIVESC_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *PrivescModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Analyzing privilege escalation in project: %s", projectID), globals.GCP_PRIVESC_MODULE_NAME)
	}

	svc := privescservice.New()
	paths, err := svc.AnalyzeProjectPrivesc(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_PRIVESC_MODULE_NAME,
			fmt.Sprintf("Could not analyze privilege escalation in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.Paths = append(m.Paths, paths...)
	for _, path := range paths {
		m.addPathToLoot(path)
	}
	m.mu.Unlock()
}

func (m *PrivescModule) initializeLootFiles() {
	m.LootMap["privesc-paths"] = &internal.LootFile{
		Name:     "privesc-paths",
		Contents: "# GCP Privilege Escalation Paths\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
	m.LootMap["privesc-commands"] = &internal.LootFile{
		Name:     "privesc-commands",
		Contents: "# GCP Privilege Escalation Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
	m.LootMap["privesc-critical"] = &internal.LootFile{
		Name:     "privesc-critical",
		Contents: "# CRITICAL Privilege Escalation Paths\n# Generated by CloudFox\n# These require immediate attention\n\n",
	}
	m.LootMap["privesc-principals"] = &internal.LootFile{
		Name:     "privesc-principals",
		Contents: "",
	}
}

func (m *PrivescModule) addPathToLoot(path privescservice.PrivescPath) {
	// All paths
	m.LootMap["privesc-paths"].Contents += fmt.Sprintf(
		"## %s - %s\n"+
			"## Principal: %s (%s)\n"+
			"## Target: %s\n"+
			"## Risk: %s\n"+
			"## Permissions: %s\n"+
			"## Description: %s\n\n",
		path.Method, path.ProjectID,
		path.Principal, path.PrincipalType,
		path.TargetResource,
		path.RiskLevel,
		strings.Join(path.Permissions, ", "),
		path.Description,
	)

	// Commands
	m.LootMap["privesc-commands"].Contents += fmt.Sprintf(
		"# %s - %s\n"+
			"# Principal: %s\n"+
			"# Risk: %s\n"+
			"%s\n\n",
		path.Method, path.ProjectID,
		path.Principal,
		path.RiskLevel,
		path.ExploitCommand,
	)

	// Critical only
	if path.RiskLevel == "CRITICAL" {
		m.LootMap["privesc-critical"].Contents += fmt.Sprintf(
			"## [CRITICAL] %s\n"+
				"## Principal: %s (%s)\n"+
				"## Project: %s\n"+
				"## Target: %s\n"+
				"## Permissions: %s\n"+
				"## Description: %s\n"+
				"## Exploit:\n"+
				"##   %s\n\n",
			path.Method,
			path.Principal, path.PrincipalType,
			path.ProjectID,
			path.TargetResource,
			strings.Join(path.Permissions, ", "),
			path.Description,
			path.ExploitCommand,
		)
	}

	// Unique principals
	m.LootMap["privesc-principals"].Contents += path.Principal + "\n"
}

func (m *PrivescModule) writeOutput(ctx context.Context, logger internal.Logger) {
	// Main privesc table
	header := []string{
		"Risk",
		"Method",
		"Principal",
		"Type",
		"Target",
		"Permissions",
		"Project Name",
		"Project",
	}

	var body [][]string
	for _, path := range m.Paths {
		perms := strings.Join(path.Permissions, ", ")
		if len(perms) > 50 {
			perms = perms[:50] + "..."
		}

		body = append(body, []string{
			path.RiskLevel,
			path.Method,
			path.Principal,
			path.PrincipalType,
			path.TargetResource,
			perms,
			m.GetProjectName(path.ProjectID),
			path.ProjectID,
		})
	}

	// Critical paths table
	critHeader := []string{
		"Method",
		"Principal",
		"Target",
		"Description",
		"Exploit Command",
		"Project Name",
		"Project",
	}

	var critBody [][]string
	for _, path := range m.Paths {
		if path.RiskLevel == "CRITICAL" {
			cmd := path.ExploitCommand
			if len(cmd) > 60 {
				cmd = cmd[:60] + "..."
			}

			critBody = append(critBody, []string{
				path.Method,
				path.Principal,
				path.TargetResource,
				path.Description,
				cmd,
				m.GetProjectName(path.ProjectID),
				path.ProjectID,
			})
		}
	}

	// By method summary
	methodHeader := []string{
		"Method",
		"Count",
		"Critical",
		"High",
		"Medium",
	}

	methodCounts := make(map[string]map[string]int)
	for _, path := range m.Paths {
		if methodCounts[path.Method] == nil {
			methodCounts[path.Method] = make(map[string]int)
		}
		methodCounts[path.Method]["total"]++
		methodCounts[path.Method][path.RiskLevel]++
	}

	var methodBody [][]string
	for method, counts := range methodCounts {
		methodBody = append(methodBody, []string{
			method,
			fmt.Sprintf("%d", counts["total"]),
			fmt.Sprintf("%d", counts["CRITICAL"]),
			fmt.Sprintf("%d", counts["HIGH"]),
			fmt.Sprintf("%d", counts["MEDIUM"]),
		})
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# Generated by CloudFox\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	tables := []internal.TableFile{
		{
			Name:   "privesc",
			Header: header,
			Body:   body,
		},
	}

	if len(critBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "privesc-critical",
			Header: critHeader,
			Body:   critBody,
		})
		logger.InfoM(fmt.Sprintf("[PENTEST] Found %d CRITICAL privilege escalation paths!", len(critBody)), globals.GCP_PRIVESC_MODULE_NAME)
	}

	if len(methodBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "privesc-summary",
			Header: methodHeader,
			Body:   methodBody,
		})
	}

	output := PrivescOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		scopeNames,
		m.ProjectIDs,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_PRIVESC_MODULE_NAME)
	}
}
