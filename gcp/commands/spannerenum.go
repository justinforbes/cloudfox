package commands

import (
	"context"
	"fmt"
	"sync"

	spannerenumservice "github.com/BishopFox/cloudfox/gcp/services/spannerEnumService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPSpannerEnumCommand = &cobra.Command{
	Use:     globals.GCP_SPANNERENUM_MODULE_NAME,
	Aliases: []string{"spanner-scan"},
	Short:   "Scan Spanner database schemas for sensitive table and column names",
	Long: `Scan Spanner database DDL for potentially sensitive data.

Retrieves DDL (CREATE TABLE statements) from all Spanner databases and parses
table names and column names, checking them against sensitive data patterns.

Detects resources with names suggesting they store:
- Credentials, tokens, or secrets
- PII (SSN, credit cards)
- Financial data (payments, billing, salary)
- Compliance-labeled data (HIPAA, GDPR, PII)`,
	Run: runGCPSpannerEnumCommand,
}

type SpannerEnumModule struct {
	gcpinternal.BaseGCPModule
	ProjectResources map[string][]spannerenumservice.SensitiveSpannerResource
	LootMap          map[string]map[string]*internal.LootFile
	mu               sync.Mutex
}

type SpannerEnumOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o SpannerEnumOutput) TableFiles() []internal.TableFile { return o.Table }
func (o SpannerEnumOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPSpannerEnumCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_SPANNERENUM_MODULE_NAME)
	if err != nil {
		return
	}

	module := &SpannerEnumModule{
		BaseGCPModule:    gcpinternal.NewBaseGCPModule(cmdCtx),
		ProjectResources: make(map[string][]spannerenumservice.SensitiveSpannerResource),
		LootMap:          make(map[string]map[string]*internal.LootFile),
	}
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *SpannerEnumModule) Execute(ctx context.Context, logger internal.Logger) {
	logger.InfoM("Scanning Spanner database schemas for sensitive data indicators...", globals.GCP_SPANNERENUM_MODULE_NAME)

	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_SPANNERENUM_MODULE_NAME, m.processProject)

	allResources := m.getAllResources()
	if len(allResources) == 0 {
		logger.InfoM("No sensitive Spanner resources found", globals.GCP_SPANNERENUM_MODULE_NAME)
		return
	}

	criticalCount := 0
	highCount := 0
	for _, r := range allResources {
		switch r.RiskLevel {
		case "CRITICAL":
			criticalCount++
		case "HIGH":
			highCount++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d sensitive Spanner resources (%d CRITICAL, %d HIGH)",
		len(allResources), criticalCount, highCount), globals.GCP_SPANNERENUM_MODULE_NAME)

	m.writeOutput(ctx, logger)
}

func (m *SpannerEnumModule) getAllResources() []spannerenumservice.SensitiveSpannerResource {
	var all []spannerenumservice.SensitiveSpannerResource
	for _, resources := range m.ProjectResources {
		all = append(all, resources...)
	}
	return all
}

func (m *SpannerEnumModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Scanning Spanner in project: %s", projectID), globals.GCP_SPANNERENUM_MODULE_NAME)
	}

	svc := spannerenumservice.New()

	resources, err := svc.EnumerateSensitiveResources(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_SPANNERENUM_MODULE_NAME,
			fmt.Sprintf("Could not scan Spanner in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.ProjectResources[projectID] = resources

	if len(resources) > 0 {
		if m.LootMap[projectID] == nil {
			m.LootMap[projectID] = make(map[string]*internal.LootFile)
		}
		lootFile := &internal.LootFile{
			Name:     "spanner-enum-commands",
			Contents: "# Spanner Commands for Sensitive Resources\n# Generated by CloudFox\n\n",
		}
		for _, r := range resources {
			if r.Table != "" {
				lootFile.Contents += fmt.Sprintf(
					"# [%s] %s - %s/%s/%s\n# %s\ngcloud spanner databases execute-sql %s --instance=%s --project=%s --sql='SELECT * FROM %s LIMIT 10'\n\n",
					r.RiskLevel, r.Category, r.Instance, r.Database, r.Table,
					r.Description,
					r.Database, r.Instance, projectID, r.Table,
				)
			}
		}
		m.LootMap[projectID]["spanner-enum-commands"] = lootFile
	}
	m.mu.Unlock()
}

func (m *SpannerEnumModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeSpannerHierarchicalOutput(ctx, logger)
	} else {
		m.writeSpannerFlatOutput(ctx, logger)
	}
}

func (m *SpannerEnumModule) getHeader() []string {
	return []string{"Project", "Instance", "Database", "Table", "Column", "Category", "Risk Level", "Description"}
}

func (m *SpannerEnumModule) resourcesToTableBody(resources []spannerenumservice.SensitiveSpannerResource) [][]string {
	var body [][]string
	for _, r := range resources {
		body = append(body, []string{
			m.GetProjectName(r.ProjectID),
			r.Instance,
			r.Database,
			r.Table,
			r.Column,
			r.Category,
			r.RiskLevel,
			r.Description,
		})
	}
	return body
}

func (m *SpannerEnumModule) buildTablesForProject(projectID string) []internal.TableFile {
	resources := m.ProjectResources[projectID]
	if len(resources) == 0 {
		return nil
	}
	return []internal.TableFile{
		{
			Name:   "spanner-enum",
			Header: m.getHeader(),
			Body:   m.resourcesToTableBody(resources),
		},
	}
}

func (m *SpannerEnumModule) writeSpannerHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	for projectID, resources := range m.ProjectResources {
		if len(resources) == 0 {
			continue
		}
		tableFiles := m.buildTablesForProject(projectID)

		var lootFiles []internal.LootFile
		if projectLoot, ok := m.LootMap[projectID]; ok {
			for _, loot := range projectLoot {
				if loot != nil && loot.Contents != "" {
					lootFiles = append(lootFiles, *loot)
				}
			}
		}

		outputData.ProjectLevelData[projectID] = SpannerEnumOutput{Table: tableFiles, Loot: lootFiles}
	}

	pathBuilder := m.BuildPathBuilder()
	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_SPANNERENUM_MODULE_NAME)
	}
}

func (m *SpannerEnumModule) writeSpannerFlatOutput(ctx context.Context, logger internal.Logger) {
	allResources := m.getAllResources()
	if len(allResources) == 0 {
		return
	}

	tables := []internal.TableFile{
		{
			Name:   "spanner-enum",
			Header: m.getHeader(),
			Body:   m.resourcesToTableBody(allResources),
		},
	}

	var lootFiles []internal.LootFile
	for _, projectLoot := range m.LootMap {
		for _, loot := range projectLoot {
			if loot != nil && loot.Contents != "" {
				lootFiles = append(lootFiles, *loot)
			}
		}
	}

	output := SpannerEnumOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart("gcp", m.Format, m.OutputDirectory, m.Verbosity, m.WrapTable,
		"project", m.ProjectIDs, scopeNames, m.Account, output)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_SPANNERENUM_MODULE_NAME)
	}
}
