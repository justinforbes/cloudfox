package commands

import (
	"context"
	"fmt"
	"sync"

	bigtableenumservice "github.com/BishopFox/cloudfox/gcp/services/bigtableEnumService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPBigtableEnumCommand = &cobra.Command{
	Use:     globals.GCP_BIGTABLEENUM_MODULE_NAME,
	Aliases: []string{"bt-enum", "bt-scan"},
	Short:   "Scan Bigtable instances, tables, and column families for sensitive data indicators",
	Long: `Scan Bigtable metadata for potentially sensitive data.

Scans instance names, table names, and column family names against sensitive
data patterns (credentials, PII, financial, compliance keywords).

Detects resources with names suggesting they store:
- Credentials, tokens, or secrets
- PII (SSN, credit cards)
- Financial data (payments, billing, salary)
- Compliance-labeled data (HIPAA, GDPR, PII)`,
	Run: runGCPBigtableEnumCommand,
}

type BigtableEnumModule struct {
	gcpinternal.BaseGCPModule
	ProjectResources map[string][]bigtableenumservice.SensitiveBTResource
	LootMap          map[string]map[string]*internal.LootFile
	mu               sync.Mutex
}

type BigtableEnumOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o BigtableEnumOutput) TableFiles() []internal.TableFile { return o.Table }
func (o BigtableEnumOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPBigtableEnumCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_BIGTABLEENUM_MODULE_NAME)
	if err != nil {
		return
	}

	module := &BigtableEnumModule{
		BaseGCPModule:    gcpinternal.NewBaseGCPModule(cmdCtx),
		ProjectResources: make(map[string][]bigtableenumservice.SensitiveBTResource),
		LootMap:          make(map[string]map[string]*internal.LootFile),
	}
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *BigtableEnumModule) Execute(ctx context.Context, logger internal.Logger) {
	logger.InfoM("Scanning Bigtable resources for sensitive data indicators...", globals.GCP_BIGTABLEENUM_MODULE_NAME)

	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_BIGTABLEENUM_MODULE_NAME, m.processProject)

	allResources := m.getAllResources()
	if len(allResources) == 0 {
		logger.InfoM("No sensitive Bigtable resources found", globals.GCP_BIGTABLEENUM_MODULE_NAME)
		return
	}

	criticalCount := 0
	highCount := 0
	for _, r := range allResources {
		switch r.RiskLevel {
		case "CRITICAL":
			criticalCount++
		case "HIGH":
			highCount++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d sensitive Bigtable resources (%d CRITICAL, %d HIGH)",
		len(allResources), criticalCount, highCount), globals.GCP_BIGTABLEENUM_MODULE_NAME)

	m.writeOutput(ctx, logger)
}

func (m *BigtableEnumModule) getAllResources() []bigtableenumservice.SensitiveBTResource {
	var all []bigtableenumservice.SensitiveBTResource
	for _, resources := range m.ProjectResources {
		all = append(all, resources...)
	}
	return all
}

func (m *BigtableEnumModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Scanning Bigtable in project: %s", projectID), globals.GCP_BIGTABLEENUM_MODULE_NAME)
	}

	svc := bigtableenumservice.New()

	resources, err := svc.EnumerateSensitiveResources(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_BIGTABLEENUM_MODULE_NAME,
			fmt.Sprintf("Could not scan Bigtable in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.ProjectResources[projectID] = resources

	if len(resources) > 0 {
		if m.LootMap[projectID] == nil {
			m.LootMap[projectID] = make(map[string]*internal.LootFile)
		}
		lootFile := &internal.LootFile{
			Name:     "bigtable-enum-commands",
			Contents: "# Bigtable Commands for Sensitive Resources\n# Generated by CloudFox\n\n",
		}
		for _, r := range resources {
			if r.Table != "" {
				lootFile.Contents += fmt.Sprintf(
					"# [%s] %s - %s/%s\n# %s\ncbt -project %s -instance %s read %s count=10\n\n",
					r.RiskLevel, r.Category, r.Instance, r.Table,
					r.Description,
					projectID, r.Instance, r.Table,
				)
			} else {
				lootFile.Contents += fmt.Sprintf(
					"# [%s] %s - instance: %s\n# %s\ncbt -project %s -instance %s ls\n\n",
					r.RiskLevel, r.Category, r.Instance,
					r.Description,
					projectID, r.Instance,
				)
			}
		}
		m.LootMap[projectID]["bigtable-enum-commands"] = lootFile
	}
	m.mu.Unlock()
}

func (m *BigtableEnumModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeBigtableHierarchicalOutput(ctx, logger)
	} else {
		m.writeBigtableFlatOutput(ctx, logger)
	}
}

func (m *BigtableEnumModule) getHeader() []string {
	return []string{"Project", "Instance", "Table", "Column Family", "Category", "Risk Level", "Description"}
}

func (m *BigtableEnumModule) resourcesToTableBody(resources []bigtableenumservice.SensitiveBTResource) [][]string {
	var body [][]string
	for _, r := range resources {
		body = append(body, []string{
			m.GetProjectName(r.ProjectID),
			r.Instance,
			r.Table,
			r.ColumnFamily,
			r.Category,
			r.RiskLevel,
			r.Description,
		})
	}
	return body
}

func (m *BigtableEnumModule) buildTablesForProject(projectID string) []internal.TableFile {
	resources := m.ProjectResources[projectID]
	if len(resources) == 0 {
		return nil
	}
	return []internal.TableFile{
		{
			Name:   "bigtable-enum",
			Header: m.getHeader(),
			Body:   m.resourcesToTableBody(resources),
		},
	}
}

func (m *BigtableEnumModule) writeBigtableHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	for projectID, resources := range m.ProjectResources {
		if len(resources) == 0 {
			continue
		}
		tableFiles := m.buildTablesForProject(projectID)

		var lootFiles []internal.LootFile
		if projectLoot, ok := m.LootMap[projectID]; ok {
			for _, loot := range projectLoot {
				if loot != nil && loot.Contents != "" {
					lootFiles = append(lootFiles, *loot)
				}
			}
		}

		outputData.ProjectLevelData[projectID] = BigtableEnumOutput{Table: tableFiles, Loot: lootFiles}
	}

	pathBuilder := m.BuildPathBuilder()
	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_BIGTABLEENUM_MODULE_NAME)
	}
}

func (m *BigtableEnumModule) writeBigtableFlatOutput(ctx context.Context, logger internal.Logger) {
	allResources := m.getAllResources()
	if len(allResources) == 0 {
		return
	}

	tables := []internal.TableFile{
		{
			Name:   "bigtable-enum",
			Header: m.getHeader(),
			Body:   m.resourcesToTableBody(allResources),
		},
	}

	var lootFiles []internal.LootFile
	for _, projectLoot := range m.LootMap {
		for _, loot := range projectLoot {
			if loot != nil && loot.Contents != "" {
				lootFiles = append(lootFiles, *loot)
			}
		}
	}

	output := BigtableEnumOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart("gcp", m.Format, m.OutputDirectory, m.Verbosity, m.WrapTable,
		"project", m.ProjectIDs, scopeNames, m.Account, output)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_BIGTABLEENUM_MODULE_NAME)
	}
}
