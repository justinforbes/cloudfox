package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	resourceiamservice "github.com/BishopFox/cloudfox/gcp/services/resourceIAMService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPResourceIAMCommand = &cobra.Command{
	Use:     globals.GCP_RESOURCEIAM_MODULE_NAME,
	Aliases: []string{"resiam", "resource-policies"},
	Short:   "Enumerate IAM policies on GCP resources (buckets, datasets, secrets, etc.)",
	Long: `Enumerate IAM policies attached directly to GCP resources.

This module discovers WHO has access to WHAT resources by enumerating
resource-level IAM policies (not just project-level policies).

Supported Resource Types:
- Cloud Storage buckets
- BigQuery datasets
- Pub/Sub topics and subscriptions
- Secret Manager secrets
- Cloud KMS keys
- Cloud Functions
- Cloud Run services

Key Findings:
- Public access (allUsers/allAuthenticatedUsers)
- Cross-project access patterns
- Overly permissive roles on sensitive resources
- Federated identity access to resources`,
	Run: runGCPResourceIAMCommand,
}

// ------------------------------
// Module Struct
// ------------------------------
type ResourceIAMModule struct {
	gcpinternal.BaseGCPModule

	ProjectBindings map[string][]resourceiamservice.ResourceIAMBinding
	LootMap         map[string]map[string]*internal.LootFile
	mu              sync.Mutex
}

// ------------------------------
// Output Struct
// ------------------------------
type ResourceIAMOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o ResourceIAMOutput) TableFiles() []internal.TableFile { return o.Table }
func (o ResourceIAMOutput) LootFiles() []internal.LootFile   { return o.Loot }

// ------------------------------
// Command Entry Point
// ------------------------------
func runGCPResourceIAMCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_RESOURCEIAM_MODULE_NAME)
	if err != nil {
		return
	}

	module := &ResourceIAMModule{
		BaseGCPModule:   gcpinternal.NewBaseGCPModule(cmdCtx),
		ProjectBindings: make(map[string][]resourceiamservice.ResourceIAMBinding),
		LootMap:         make(map[string]map[string]*internal.LootFile),
	}

	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

// ------------------------------
// Module Execution
// ------------------------------
func (m *ResourceIAMModule) Execute(ctx context.Context, logger internal.Logger) {
	logger.InfoM("Enumerating resource-level IAM policies...", globals.GCP_RESOURCEIAM_MODULE_NAME)

	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_RESOURCEIAM_MODULE_NAME, m.processProject)

	allBindings := m.getAllBindings()
	if len(allBindings) == 0 {
		logger.InfoM("No resource IAM bindings found", globals.GCP_RESOURCEIAM_MODULE_NAME)
		return
	}

	// Count statistics
	publicCount := 0
	resourceTypes := make(map[string]int)
	for _, b := range allBindings {
		resourceTypes[b.ResourceType]++
		if b.IsPublic {
			publicCount++
		}
	}

	// Build summary
	var typeSummary []string
	for rt, count := range resourceTypes {
		typeSummary = append(typeSummary, fmt.Sprintf("%d %s(s)", count, rt))
	}

	logger.SuccessM(fmt.Sprintf("Found %d resource IAM binding(s): %s",
		len(allBindings), strings.Join(typeSummary, ", ")), globals.GCP_RESOURCEIAM_MODULE_NAME)

	if publicCount > 0 {
		logger.InfoM(fmt.Sprintf("[FINDING] Found %d PUBLIC resource binding(s)!", publicCount), globals.GCP_RESOURCEIAM_MODULE_NAME)
	}

	m.writeOutput(ctx, logger)
}

// ------------------------------
// Project Processor
// ------------------------------
func (m *ResourceIAMModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating resource IAM in project: %s", projectID), globals.GCP_RESOURCEIAM_MODULE_NAME)
	}

	// Initialize loot for this project
	m.mu.Lock()
	if m.LootMap[projectID] == nil {
		m.LootMap[projectID] = make(map[string]*internal.LootFile)
	}
	m.LootMap[projectID]["resource-iam-commands"] = &internal.LootFile{
		Name:     "resource-iam-commands",
		Contents: "# Resource IAM Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
	m.LootMap[projectID]["public-resources"] = &internal.LootFile{
		Name:     "public-resources",
		Contents: "# Public Resources\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
	m.mu.Unlock()

	svc := resourceiamservice.New()
	bindings, err := svc.GetAllResourceIAM(ctx, projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_RESOURCEIAM_MODULE_NAME,
			fmt.Sprintf("Could not enumerate resource IAM in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.ProjectBindings[projectID] = append(m.ProjectBindings[projectID], bindings...)

	// Generate loot for all resources
	for _, b := range bindings {
		m.addResourceToLoot(b, projectID)
		if b.IsPublic {
			m.addPublicResourceToLoot(b, projectID)
		}
	}
	m.mu.Unlock()

	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Found %d resource IAM binding(s) in project %s", len(bindings), projectID), globals.GCP_RESOURCEIAM_MODULE_NAME)
	}
}

// getAllBindings aggregates all bindings across projects
func (m *ResourceIAMModule) getAllBindings() []resourceiamservice.ResourceIAMBinding {
	var allBindings []resourceiamservice.ResourceIAMBinding
	for _, bindings := range m.ProjectBindings {
		allBindings = append(allBindings, bindings...)
	}
	return allBindings
}

// ------------------------------
// Loot Management
// ------------------------------
func (m *ResourceIAMModule) addResourceToLoot(b resourceiamservice.ResourceIAMBinding, projectID string) {
	lootFile := m.LootMap[projectID]["resource-iam-commands"]
	if lootFile == nil {
		return
	}

	// Generate enumeration and exploit commands based on resource type
	switch b.ResourceType {
	case "bucket":
		lootFile.Contents += fmt.Sprintf(
			"# Bucket: %s (Member: %s, Role: %s)\n"+
				"gsutil iam get %s\n"+
				"gsutil ls %s\n"+
				"gsutil ls -L %s\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceName, b.ResourceName, b.ResourceName,
		)
	case "dataset":
		lootFile.Contents += fmt.Sprintf(
			"# BigQuery Dataset: %s (Member: %s, Role: %s)\n"+
				"bq show --format=prettyjson %s\n"+
				"bq ls %s\n"+
				"bq query --use_legacy_sql=false 'SELECT table_name FROM `%s`.INFORMATION_SCHEMA.TABLES'\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceName, b.ResourceName, b.ResourceID,
		)
	case "topic":
		lootFile.Contents += fmt.Sprintf(
			"# Pub/Sub Topic: %s (Member: %s, Role: %s)\n"+
				"gcloud pubsub topics describe %s --project=%s\n"+
				"gcloud pubsub topics get-iam-policy %s --project=%s\n"+
				"# Create a subscription to read messages:\n"+
				"gcloud pubsub subscriptions create cloudfox-tap-%s --topic=%s --project=%s\n"+
				"gcloud pubsub subscriptions pull cloudfox-tap-%s --auto-ack --limit=10 --project=%s\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
		)
	case "subscription":
		lootFile.Contents += fmt.Sprintf(
			"# Pub/Sub Subscription: %s (Member: %s, Role: %s)\n"+
				"gcloud pubsub subscriptions describe %s --project=%s\n"+
				"gcloud pubsub subscriptions get-iam-policy %s --project=%s\n"+
				"# Pull messages from subscription:\n"+
				"gcloud pubsub subscriptions pull %s --auto-ack --limit=10 --project=%s\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
		)
	case "secret":
		lootFile.Contents += fmt.Sprintf(
			"# Secret Manager Secret: %s (Member: %s, Role: %s)\n"+
				"gcloud secrets describe %s --project=%s\n"+
				"gcloud secrets versions list %s --project=%s\n"+
				"gcloud secrets versions access latest --secret=%s --project=%s\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
		)
	case "cryptokey":
		lootFile.Contents += fmt.Sprintf(
			"# KMS CryptoKey: %s (Member: %s, Role: %s)\n"+
				"gcloud kms keys describe %s --format=json\n"+
				"gcloud kms keys get-iam-policy %s\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceName, b.ResourceName,
		)
	case "function":
		lootFile.Contents += fmt.Sprintf(
			"# Cloud Function: %s (Member: %s, Role: %s)\n"+
				"gcloud functions describe %s --project=%s\n"+
				"gcloud functions get-iam-policy %s --project=%s\n"+
				"# Invoke function (if invoker role):\n"+
				"gcloud functions call %s --project=%s\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
		)
	case "cloudrun":
		lootFile.Contents += fmt.Sprintf(
			"# Cloud Run Service: %s (Member: %s, Role: %s)\n"+
				"gcloud run services describe %s --project=%s --format=json\n"+
				"gcloud run services get-iam-policy %s --project=%s\n"+
				"# Get service URL and test access:\n"+
				"gcloud run services describe %s --project=%s --format='value(status.url)'\n\n",
			b.ResourceName, b.Member, b.Role,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
			b.ResourceID, b.ProjectID,
		)
	}
}

func (m *ResourceIAMModule) addPublicResourceToLoot(b resourceiamservice.ResourceIAMBinding, projectID string) {
	lootFile := m.LootMap[projectID]["public-resources"]
	if lootFile == nil {
		return
	}

	lootFile.Contents += fmt.Sprintf(
		"# %s: %s\n# Member: %s, Role: %s\n",
		b.ResourceType, b.ResourceName, b.Member, b.Role,
	)

	// Add exploitation commands based on resource type
	switch b.ResourceType {
	case "bucket":
		lootFile.Contents += fmt.Sprintf(
			"gsutil ls %s\ngsutil cat %s/*\n\n",
			b.ResourceName, b.ResourceName,
		)
	case "function":
		lootFile.Contents += fmt.Sprintf(
			"# Function may be publicly invokable\ngcloud functions describe %s --project=%s\n\n",
			b.ResourceID, b.ProjectID,
		)
	case "cloudrun":
		lootFile.Contents += fmt.Sprintf(
			"# Cloud Run service may be publicly accessible\ngcloud run services describe %s --project=%s\n\n",
			b.ResourceID, b.ProjectID,
		)
	}
}

// resourceKey creates a unique key for a resource to group bindings
func resourceKey(b resourceiamservice.ResourceIAMBinding) string {
	return fmt.Sprintf("%s|%s|%s", b.ProjectID, b.ResourceType, b.ResourceName)
}

// shortenRole extracts a readable role name from the full role path
func shortenRole(role string) string {
	// roles/storage.objectViewer -> objectViewer
	// projects/xxx/roles/customRole -> customRole
	if idx := strings.LastIndex(role, "/"); idx != -1 {
		return role[idx+1:]
	}
	return role
}

// ------------------------------
// Output Generation
// ------------------------------
func (m *ResourceIAMModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeHierarchicalOutput(ctx, logger)
	} else {
		m.writeFlatOutput(ctx, logger)
	}
}

func (m *ResourceIAMModule) writeHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	pathBuilder := m.BuildPathBuilder()

	// Build per-project output data
	projectLevelData := make(map[string]internal.CloudfoxOutput)

	for projectID, bindings := range m.ProjectBindings {
		header := []string{
			"Resource Type",
			"Resource ID",
			"Resource Name",
			"Public",
			"Access (memberType:member [role])",
			"Condition",
		}

		// Group bindings by resource
		resourceBindings := make(map[string][]resourceiamservice.ResourceIAMBinding)
		resourceOrder := []string{} // Maintain order
		for _, b := range bindings {
			key := resourceKey(b)
			if _, exists := resourceBindings[key]; !exists {
				resourceOrder = append(resourceOrder, key)
			}
			resourceBindings[key] = append(resourceBindings[key], b)
		}

		var body [][]string
		for _, key := range resourceOrder {
			groupBindings := resourceBindings[key]
			if len(groupBindings) == 0 {
				continue
			}

			// Use first binding for resource info
			first := groupBindings[0]

			// Check if any binding is public
			isPublic := "No"
			for _, b := range groupBindings {
				if b.IsPublic {
					isPublic = "Yes"
					break
				}
			}

			// Build access list: one line per entity "memberType:member [role]"
			var accessList []string
			var conditionList []string
			for _, b := range groupBindings {
				// Format: memberType:member [shortRole]
				member := b.MemberEmail
				if member == "" {
					member = b.Member
				}
				memberType := strings.ToLower(b.MemberType)
				role := shortenRole(b.Role)

				entry := fmt.Sprintf("%s:%s [%s]", memberType, member, role)
				accessList = append(accessList, entry)

				// Collect condition expressions
				if b.HasCondition && b.ConditionExpression != "" {
					condEntry := b.ConditionExpression
					if b.ConditionTitle != "" {
						condEntry = fmt.Sprintf("%s: %s", b.ConditionTitle, b.ConditionExpression)
					}
					// Avoid duplicates
					found := false
					for _, existing := range conditionList {
						if existing == condEntry {
							found = true
							break
						}
					}
					if !found {
						conditionList = append(conditionList, condEntry)
					}
				}
			}

			condition := "-"
			if len(conditionList) > 0 {
				condition = strings.Join(conditionList, "\n")
			}

			body = append(body, []string{
				first.ResourceType,
				first.ResourceID,
				first.ResourceName,
				isPublic,
				strings.Join(accessList, "\n"),
				condition,
			})
		}

		// Collect loot files for this project
		var lootFiles []internal.LootFile
		if projectLoot, ok := m.LootMap[projectID]; ok {
			for _, loot := range projectLoot {
				if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
					lootFiles = append(lootFiles, *loot)
				}
			}
		}

		tables := []internal.TableFile{
			{
				Name:   "resource-iam",
				Header: header,
				Body:   body,
			},
		}

		projectLevelData[projectID] = ResourceIAMOutput{
			Table: tables,
			Loot:  lootFiles,
		}
	}

	outputData := internal.HierarchicalOutputData{
		ProjectLevelData: projectLevelData,
	}

	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_RESOURCEIAM_MODULE_NAME)
		m.CommandCounter.Error++
	}
}

func (m *ResourceIAMModule) writeFlatOutput(ctx context.Context, logger internal.Logger) {
	allBindings := m.getAllBindings()

	header := []string{
		"Project ID",
		"Resource Type",
		"Resource ID",
		"Resource Name",
		"Public",
		"Access (memberType:member [role])",
		"Condition",
	}

	// Group bindings by resource
	resourceBindings := make(map[string][]resourceiamservice.ResourceIAMBinding)
	resourceOrder := []string{} // Maintain order
	for _, b := range allBindings {
		key := resourceKey(b)
		if _, exists := resourceBindings[key]; !exists {
			resourceOrder = append(resourceOrder, key)
		}
		resourceBindings[key] = append(resourceBindings[key], b)
	}

	var body [][]string
	for _, key := range resourceOrder {
		bindings := resourceBindings[key]
		if len(bindings) == 0 {
			continue
		}

		// Use first binding for resource info
		first := bindings[0]

		// Check if any binding is public
		isPublic := "No"
		for _, b := range bindings {
			if b.IsPublic {
				isPublic = "Yes"
				break
			}
		}

		// Build access list: one line per entity "memberType:member [role]"
		var accessList []string
		var conditionList []string
		for _, b := range bindings {
			// Format: memberType:member [shortRole]
			member := b.MemberEmail
			if member == "" {
				member = b.Member
			}
			memberType := strings.ToLower(b.MemberType)
			role := shortenRole(b.Role)

			entry := fmt.Sprintf("%s:%s [%s]", memberType, member, role)
			accessList = append(accessList, entry)

			// Collect condition expressions
			if b.HasCondition && b.ConditionExpression != "" {
				condEntry := b.ConditionExpression
				if b.ConditionTitle != "" {
					condEntry = fmt.Sprintf("%s: %s", b.ConditionTitle, b.ConditionExpression)
				}
				// Avoid duplicates
				found := false
				for _, existing := range conditionList {
					if existing == condEntry {
						found = true
						break
					}
				}
				if !found {
					conditionList = append(conditionList, condEntry)
				}
			}
		}

		condition := "-"
		if len(conditionList) > 0 {
			condition = strings.Join(conditionList, "\n")
		}

		body = append(body, []string{
			first.ProjectID,
			first.ResourceType,
			first.ResourceID,
			first.ResourceName,
			isPublic,
			strings.Join(accessList, "\n"),
			condition,
		})
	}

	// Collect all loot files
	var lootFiles []internal.LootFile
	for _, projectLoot := range m.LootMap {
		for _, loot := range projectLoot {
			if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
				lootFiles = append(lootFiles, *loot)
			}
		}
	}

	tables := []internal.TableFile{
		{
			Name:   "resource-iam",
			Header: header,
			Body:   body,
		},
	}

	output := ResourceIAMOutput{
		Table: tables,
		Loot:  lootFiles,
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		m.ProjectIDs,
		[]string{},
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_RESOURCEIAM_MODULE_NAME)
		m.CommandCounter.Error++
	}
}
