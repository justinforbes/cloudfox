package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"

	hmacservice "github.com/BishopFox/cloudfox/gcp/services/hmacService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPHMACKeysCommand = &cobra.Command{
	Use:     globals.GCP_HMACKEYS_MODULE_NAME,
	Aliases: []string{"hmac", "s3keys", "storage-keys"},
	Short:   "Enumerate GCS HMAC keys (S3-compatible access)",
	Long: `Enumerate GCS HMAC keys for S3-compatible access.

HMAC keys provide S3-compatible access to Google Cloud Storage buckets.
These are often overlooked credentials that can persist even after other
access is revoked.

Features:
- Lists all HMAC keys with service account associations
- Identifies active vs inactive keys
- Detects old keys needing rotation
- Generates S3-compatible access commands for penetration testing`,
	Run: runGCPHMACKeysCommand,
}

type HMACKeysModule struct {
	gcpinternal.BaseGCPModule
	HMACKeys []hmacservice.HMACKeyInfo
	LootMap  map[string]*internal.LootFile
	mu       sync.Mutex
}

type HMACKeysOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o HMACKeysOutput) TableFiles() []internal.TableFile { return o.Table }
func (o HMACKeysOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPHMACKeysCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_HMACKEYS_MODULE_NAME)
	if err != nil {
		return
	}

	module := &HMACKeysModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		HMACKeys:      []hmacservice.HMACKeyInfo{},
		LootMap:       make(map[string]*internal.LootFile),
	}
	module.initializeLootFiles()
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *HMACKeysModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_HMACKEYS_MODULE_NAME, m.processProject)

	if len(m.HMACKeys) == 0 {
		logger.InfoM("No HMAC keys found", globals.GCP_HMACKEYS_MODULE_NAME)
		return
	}

	// Count active keys
	activeCount := 0
	for _, key := range m.HMACKeys {
		if key.IsActive {
			activeCount++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d HMAC key(s) (%d active)", len(m.HMACKeys), activeCount), globals.GCP_HMACKEYS_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *HMACKeysModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating HMAC keys in project: %s", projectID), globals.GCP_HMACKEYS_MODULE_NAME)
	}

	svc := hmacservice.New()
	keys, err := svc.ListHMACKeys(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_HMACKEYS_MODULE_NAME,
			fmt.Sprintf("Could not enumerate HMAC keys in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.HMACKeys = append(m.HMACKeys, keys...)
	for _, key := range keys {
		m.addKeyToLoot(key)
	}
	m.mu.Unlock()
}

func (m *HMACKeysModule) initializeLootFiles() {
	m.LootMap["hmac-active-keys"] = &internal.LootFile{
		Name:     "hmac-active-keys",
		Contents: "# Active HMAC Keys (S3-compatible access)\n# Generated by CloudFox\n# These can be used with AWS CLI for GCS access\n\n",
	}
	m.LootMap["hmac-s3-commands"] = &internal.LootFile{
		Name:     "hmac-s3-commands",
		Contents: "# S3-Compatible Access Commands for GCS\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
	m.LootMap["hmac-all-access-ids"] = &internal.LootFile{
		Name:     "hmac-all-access-ids",
		Contents: "",
	}
}

func (m *HMACKeysModule) addKeyToLoot(key hmacservice.HMACKeyInfo) {
	// All access IDs
	m.LootMap["hmac-all-access-ids"].Contents += key.AccessID + "\n"

	if key.IsActive {
		// Active keys loot
		m.LootMap["hmac-active-keys"].Contents += fmt.Sprintf(
			"# Access ID: %s\n"+
				"# Service Account: %s\n"+
				"# Project: %s\n"+
				"# Created: %s\n"+
				"# Risk: %s\n",
			key.AccessID,
			key.ServiceAccountEmail,
			key.ProjectID,
			key.TimeCreated.Format(time.RFC3339),
			key.RiskLevel,
		)
		if len(key.RiskReasons) > 0 {
			m.LootMap["hmac-active-keys"].Contents += "# Risk Reasons:\n"
			for _, reason := range key.RiskReasons {
				m.LootMap["hmac-active-keys"].Contents += fmt.Sprintf("#   - %s\n", reason)
			}
		}
		m.LootMap["hmac-active-keys"].Contents += "\n"

		// S3 commands loot
		m.LootMap["hmac-s3-commands"].Contents += fmt.Sprintf(
			"## HMAC Key: %s\n"+
				"## Service Account: %s\n"+
				"## Project: %s\n\n"+
				"# Step 1: Configure AWS CLI with HMAC credentials\n"+
				"# You need the secret key which must be obtained at creation time\n"+
				"# If you have iam.serviceAccountKeys.create permission, create a new key:\n"+
				"# gcloud storage hmac create %s --project=%s\n\n"+
				"# Step 2: Use with AWS CLI (after configuration)\n"+
				"aws configure set aws_access_key_id %s\n"+
				"aws configure set aws_secret_access_key <SECRET_KEY_HERE>\n\n"+
				"# Step 3: List buckets via S3-compatible endpoint\n"+
				"aws --endpoint-url https://storage.googleapis.com s3 ls\n\n"+
				"# Step 4: Access specific bucket\n"+
				"aws --endpoint-url https://storage.googleapis.com s3 ls s3://<BUCKET_NAME>\n\n"+
				"# Step 5: Download files\n"+
				"aws --endpoint-url https://storage.googleapis.com s3 cp s3://<BUCKET_NAME>/<FILE> .\n\n",
			key.AccessID,
			key.ServiceAccountEmail,
			key.ProjectID,
			key.ServiceAccountEmail,
			key.ProjectID,
			key.AccessID,
		)
	}
}

func (m *HMACKeysModule) writeOutput(ctx context.Context, logger internal.Logger) {
	// Main HMAC keys table
	header := []string{
		"Access ID",
		"Service Account",
		"State",
		"Created",
		"Age (Days)",
		"Risk",
		"Project Name",
		"Project",
	}

	var body [][]string
	for _, key := range m.HMACKeys {
		age := "-"
		if !key.TimeCreated.IsZero() {
			ageDays := int(time.Since(key.TimeCreated).Hours() / 24)
			age = fmt.Sprintf("%d", ageDays)
		}

		body = append(body, []string{
			key.AccessID,
			key.ServiceAccountEmail,
			key.State,
			key.TimeCreated.Format("2006-01-02"),
			age,
			key.RiskLevel,
			m.GetProjectName(key.ProjectID),
			key.ProjectID,
		})
	}

	// Active keys table
	activeHeader := []string{
		"Access ID",
		"Service Account",
		"Created",
		"Risk",
		"Risk Reasons",
		"Project Name",
		"Project",
	}

	var activeBody [][]string
	for _, key := range m.HMACKeys {
		if key.IsActive {
			activeBody = append(activeBody, []string{
				key.AccessID,
				key.ServiceAccountEmail,
				key.TimeCreated.Format("2006-01-02"),
				key.RiskLevel,
				strings.Join(key.RiskReasons, "; "),
				m.GetProjectName(key.ProjectID),
				key.ProjectID,
			})
		}
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# Generated by CloudFox\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	tables := []internal.TableFile{
		{
			Name:   "hmackeys",
			Header: header,
			Body:   body,
		},
	}

	if len(activeBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "hmackeys-active",
			Header: activeHeader,
			Body:   activeBody,
		})
		logger.InfoM(fmt.Sprintf("[PENTEST] Found %d active HMAC key(s) for S3-compatible access", len(activeBody)), globals.GCP_HMACKEYS_MODULE_NAME)
	}

	output := HMACKeysOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		scopeNames,
		m.ProjectIDs,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_HMACKEYS_MODULE_NAME)
	}
}
