package commands

import (
	"context"
	"fmt"
	"strings"

	orgsservice "github.com/BishopFox/cloudfox/gcp/services/organizationsService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPOrganizationsCommand = &cobra.Command{
	Use:     globals.GCP_ORGANIZATIONS_MODULE_NAME,
	Aliases: []string{"org", "orgs", "hierarchy"},
	Short:   "Enumerate GCP organization hierarchy",
	Long: `Enumerate GCP organization, folder, and project hierarchy.

Features:
- Lists accessible organizations
- Shows folder structure
- Maps project relationships
- Displays resource hierarchy tree
- Shows ancestry paths for projects`,
	Run: runGCPOrganizationsCommand,
}

// ------------------------------
// Module Struct with embedded BaseGCPModule
// ------------------------------
type OrganizationsModule struct {
	gcpinternal.BaseGCPModule

	// Module-specific fields
	Organizations []orgsservice.OrganizationInfo
	Folders       []orgsservice.FolderInfo
	Projects      []orgsservice.ProjectInfo
	Ancestry      [][]orgsservice.HierarchyNode
	LootMap       map[string]*internal.LootFile
}

// ------------------------------
// Output Struct implementing CloudfoxOutput interface
// ------------------------------
type OrganizationsOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o OrganizationsOutput) TableFiles() []internal.TableFile { return o.Table }
func (o OrganizationsOutput) LootFiles() []internal.LootFile   { return o.Loot }

// ------------------------------
// Command Entry Point
// ------------------------------
func runGCPOrganizationsCommand(cmd *cobra.Command, args []string) {
	// Initialize command context
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_ORGANIZATIONS_MODULE_NAME)
	if err != nil {
		return // Error already logged
	}

	// Create module instance
	module := &OrganizationsModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Organizations: []orgsservice.OrganizationInfo{},
		Folders:       []orgsservice.FolderInfo{},
		Projects:      []orgsservice.ProjectInfo{},
		Ancestry:      [][]orgsservice.HierarchyNode{},
		LootMap:       make(map[string]*internal.LootFile),
	}

	// Initialize loot files
	module.initializeLootFiles()

	// Execute enumeration
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

// ------------------------------
// Module Execution
// ------------------------------
func (m *OrganizationsModule) Execute(ctx context.Context, logger internal.Logger) {
	orgsSvc := orgsservice.New()

	// Get organizations
	orgs, err := orgsSvc.SearchOrganizations()
	if err != nil {
		logger.InfoM(fmt.Sprintf("Could not enumerate organizations: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
	} else {
		m.Organizations = orgs
	}

	// Get all folders
	folders, err := orgsSvc.SearchAllFolders()
	if err != nil {
		logger.InfoM(fmt.Sprintf("Could not enumerate folders: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
	} else {
		m.Folders = folders
	}

	// Get all projects
	projects, err := orgsSvc.SearchProjects("")
	if err != nil {
		logger.InfoM(fmt.Sprintf("Could not enumerate projects: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
	} else {
		m.Projects = projects
	}

	// Get ancestry for each specified project
	for _, projectID := range m.ProjectIDs {
		ancestry, err := orgsSvc.GetProjectAncestry(projectID)
		if err != nil {
			logger.InfoM(fmt.Sprintf("Could not get ancestry for project %s: %v", projectID, err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
		} else {
			m.Ancestry = append(m.Ancestry, ancestry)
		}
	}

	// Generate loot
	m.generateLoot()

	// Report findings
	logger.SuccessM(fmt.Sprintf("Found %d organization(s), %d folder(s), %d project(s)",
		len(m.Organizations), len(m.Folders), len(m.Projects)), globals.GCP_ORGANIZATIONS_MODULE_NAME)

	// Write output
	m.writeOutput(ctx, logger)
}

// ------------------------------
// Loot File Management
// ------------------------------
func (m *OrganizationsModule) initializeLootFiles() {
	m.LootMap["organizations-commands"] = &internal.LootFile{
		Name:     "organizations-commands",
		Contents: "# GCP Organization Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
}

func (m *OrganizationsModule) generateLoot() {
	// Hierarchy visualization
	m.LootMap["organizations-commands"].Contents += "# ==========================================\n"
	m.LootMap["organizations-commands"].Contents += "# ORGANIZATION HIERARCHY\n"
	m.LootMap["organizations-commands"].Contents += "# ==========================================\n\n"

	for _, org := range m.Organizations {
		orgID := strings.TrimPrefix(org.Name, "organizations/")
		m.LootMap["organizations-commands"].Contents += fmt.Sprintf("Organization: %s (%s)\n", org.DisplayName, orgID)

		// Find folders directly under this org
		for _, folder := range m.Folders {
			if folder.Parent == org.Name {
				m.addFolderToHierarchy(folder, 1)
			}
		}

		// Find projects directly under this org
		for _, proj := range m.Projects {
			if proj.Parent == org.Name {
				m.LootMap["organizations-commands"].Contents += fmt.Sprintf("  └── Project: %s (%s)\n", proj.DisplayName, proj.ProjectID)
			}
		}
		m.LootMap["organizations-commands"].Contents += "\n"
	}

	// Gcloud commands for organizations
	m.LootMap["organizations-commands"].Contents += "# ==========================================\n"
	m.LootMap["organizations-commands"].Contents += "# ORGANIZATION COMMANDS\n"
	m.LootMap["organizations-commands"].Contents += "# ==========================================\n\n"

	for _, org := range m.Organizations {
		orgID := strings.TrimPrefix(org.Name, "organizations/")
		m.LootMap["organizations-commands"].Contents += fmt.Sprintf(
			"## Organization: %s (%s)\n"+
				"gcloud organizations describe %s\n"+
				"gcloud organizations get-iam-policy %s\n"+
				"gcloud resource-manager folders list --organization=%s\n"+
				"gcloud projects list --filter='parent.id=%s'\n\n",
			org.DisplayName, orgID,
			orgID,
			orgID,
			orgID,
			orgID,
		)
	}

	// Gcloud commands for folders
	if len(m.Folders) > 0 {
		m.LootMap["organizations-commands"].Contents += "# ==========================================\n"
		m.LootMap["organizations-commands"].Contents += "# FOLDER COMMANDS\n"
		m.LootMap["organizations-commands"].Contents += "# ==========================================\n\n"

		for _, folder := range m.Folders {
			folderID := strings.TrimPrefix(folder.Name, "folders/")
			m.LootMap["organizations-commands"].Contents += fmt.Sprintf(
				"## Folder: %s (%s)\n"+
					"gcloud resource-manager folders describe %s\n"+
					"gcloud resource-manager folders get-iam-policy %s\n"+
					"gcloud resource-manager folders list --folder=%s\n"+
					"gcloud projects list --filter='parent.id=%s'\n\n",
				folder.DisplayName, folderID,
				folderID,
				folderID,
				folderID,
				folderID,
			)
		}
	}
}

func (m *OrganizationsModule) addFolderToHierarchy(folder orgsservice.FolderInfo, depth int) {
	indent := strings.Repeat("  ", depth)
	folderID := strings.TrimPrefix(folder.Name, "folders/")
	m.LootMap["organizations-commands"].Contents += fmt.Sprintf("%s├── Folder: %s (%s)\n", indent, folder.DisplayName, folderID)

	// Find child folders
	for _, childFolder := range m.Folders {
		if childFolder.Parent == folder.Name {
			m.addFolderToHierarchy(childFolder, depth+1)
		}
	}

	// Find projects under this folder
	for _, proj := range m.Projects {
		if proj.Parent == folder.Name {
			m.LootMap["organizations-commands"].Contents += fmt.Sprintf("%s  └── Project: %s (%s)\n", indent, proj.DisplayName, proj.ProjectID)
		}
	}
}

// ------------------------------
// Output Generation
// ------------------------------
func (m *OrganizationsModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeHierarchicalOutput(ctx, logger)
	} else {
		m.writeFlatOutput(ctx, logger)
	}
}

func (m *OrganizationsModule) buildTables() []internal.TableFile {
	// Organizations table
	orgsHeader := []string{
		"Organization ID",
		"Display Name",
		"State",
		"Directory ID",
	}

	var orgsBody [][]string
	for _, org := range m.Organizations {
		orgID := strings.TrimPrefix(org.Name, "organizations/")
		orgsBody = append(orgsBody, []string{
			orgID,
			org.DisplayName,
			org.State,
			org.DirectoryID,
		})
	}

	// Folders table
	foldersHeader := []string{
		"Folder ID",
		"Display Name",
		"Parent",
		"State",
	}

	var foldersBody [][]string
	for _, folder := range m.Folders {
		folderID := strings.TrimPrefix(folder.Name, "folders/")
		foldersBody = append(foldersBody, []string{
			folderID,
			folder.DisplayName,
			folder.Parent,
			folder.State,
		})
	}

	// Projects table
	projectsHeader := []string{
		"Project ID",
		"Project Name",
		"Display Name",
		"Parent",
		"State",
	}

	var projectsBody [][]string
	for _, proj := range m.Projects {
		projectsBody = append(projectsBody, []string{
			proj.ProjectID,
			m.GetProjectName(proj.ProjectID),
			proj.DisplayName,
			proj.Parent,
			proj.State,
		})
	}

	// Ancestry table
	ancestryHeader := []string{
		"Project ID",
		"Project Name",
		"Ancestry Path",
	}

	var ancestryBody [][]string
	for _, ancestry := range m.Ancestry {
		if len(ancestry) > 0 {
			// Build ancestry path string
			var path []string
			projectID := ""
			for _, node := range ancestry {
				if node.Type == "project" {
					projectID = node.ID
				}
				path = append(path, fmt.Sprintf("%s:%s", node.Type, node.ID))
			}
			ancestryBody = append(ancestryBody, []string{
				projectID,
				m.GetProjectName(projectID),
				strings.Join(path, " -> "),
			})
		}
	}

	// Build tables
	var tables []internal.TableFile

	if len(orgsBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "organizations",
			Header: orgsHeader,
			Body:   orgsBody,
		})
	}

	if len(foldersBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "folders",
			Header: foldersHeader,
			Body:   foldersBody,
		})
	}

	if len(projectsBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "projects",
			Header: projectsHeader,
			Body:   projectsBody,
		})
	}

	if len(ancestryBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "ancestry",
			Header: ancestryHeader,
			Body:   ancestryBody,
		})
	}

	return tables
}

func (m *OrganizationsModule) collectLootFiles() []internal.LootFile {
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}
	return lootFiles
}

func (m *OrganizationsModule) writeHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	// For organizations module, output at org level since it enumerates the whole hierarchy
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	tables := m.buildTables()
	lootFiles := m.collectLootFiles()

	output := OrganizationsOutput{
		Table: tables,
		Loot:  lootFiles,
	}

	// Determine output location - prefer org-level, fall back to project-level
	orgID := ""

	// First, try to get org ID from the hierarchy
	if m.Hierarchy != nil && len(m.Hierarchy.Organizations) > 0 {
		orgID = m.Hierarchy.Organizations[0].ID
	} else if len(m.Organizations) > 0 {
		// Fall back to enumerated organizations if hierarchy not available
		orgID = strings.TrimPrefix(m.Organizations[0].Name, "organizations/")
	}

	// Ensure hierarchy has display names from our enumeration
	// This handles the case where the hierarchy was built before we enumerated orgs
	if m.Hierarchy != nil && len(m.Organizations) > 0 {
		for _, org := range m.Organizations {
			numericID := strings.TrimPrefix(org.Name, "organizations/")
			// Update display name in hierarchy if we have a better one
			for i := range m.Hierarchy.Organizations {
				if m.Hierarchy.Organizations[i].ID == numericID {
					if m.Hierarchy.Organizations[i].DisplayName == "" && org.DisplayName != "" {
						m.Hierarchy.Organizations[i].DisplayName = org.DisplayName
					}
					break
				}
			}
		}
	}

	if orgID != "" {
		// Place at org level
		outputData.OrgLevelData[orgID] = output
	} else if len(m.ProjectIDs) > 0 {
		// Fall back to first project level if no org discovered
		outputData.ProjectLevelData[m.ProjectIDs[0]] = output
	}

	pathBuilder := m.BuildPathBuilder()

	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
		m.CommandCounter.Error++
	}
}

func (m *OrganizationsModule) writeFlatOutput(ctx context.Context, logger internal.Logger) {
	tables := m.buildTables()
	lootFiles := m.collectLootFiles()

	output := OrganizationsOutput{
		Table: tables,
		Loot:  lootFiles,
	}

	// Write output using HandleOutputSmart with scope support
	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}
	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",           // scopeType
		m.ProjectIDs,        // scopeIdentifiers
		scopeNames,          // scopeNames
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
		m.CommandCounter.Error++
	}
}
