package commands

import (
	"context"
	"fmt"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"sync"

	foxmapperservice "github.com/BishopFox/cloudfox/gcp/services/foxmapperService"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPFoxMapperCommand = &cobra.Command{
	Use:     "foxmapper",
	Aliases: []string{"fm", "pmapper"},
	Short:   "Display privilege escalation data from FoxMapper graphs",
	Long: `Display and analyze privilege escalation paths from FoxMapper graph data.

This command reads FoxMapper graph data (generated by 'foxmapper gcp graph create')
and displays privilege escalation analysis results. It's the GCP equivalent of
CloudFox's AWS pmapper integration.

FoxMapper creates a graph of principals (service accounts, users, groups) and
privilege escalation edges between them. This command queries that graph to:

1. List all admin principals
2. List all principals with paths to admin
3. Display detailed escalation paths
4. Show statistics and summaries

FoxMapper data locations (checked in order):
- Linux: ~/.local/share/foxmapper/gcp/{org_id or project_id}/
- macOS: ~/Library/Application Support/foxmapper/gcp/{org_id or project_id}/
- Windows: %APPDATA%/foxmapper/gcp/{org_id or project_id}/

To generate FoxMapper data, run:
  foxmapper gcp graph create --org {org_id}
  foxmapper gcp graph create --project {project_id}

Examples:
  # Display privesc analysis for an organization
  cloudfox gcp foxmapper --org 123456789

  # Display privesc analysis for a specific project
  cloudfox gcp foxmapper --project my-project

  # Use a custom FoxMapper data path
  cloudfox gcp foxmapper --foxmapper-path /path/to/foxmapper/gcp/123456789`,
	Run: runGCPFoxMapperCommand,
}

// Module-specific flags
var (
	foxmapperOrgID     string
	foxmapperProjectID string
	foxmapperDataPath  string
)

func init() {
	GCPFoxMapperCommand.Flags().StringVar(&foxmapperOrgID, "org", "", "Organization ID to analyze")
	GCPFoxMapperCommand.Flags().StringVar(&foxmapperProjectID, "project", "", "Project ID to analyze (if not using org)")
	GCPFoxMapperCommand.Flags().StringVar(&foxmapperDataPath, "foxmapper-path", "", "Custom path to FoxMapper data directory")
}

// FoxMapperModule holds the state for the FoxMapper command
type FoxMapperModule struct {
	gcpinternal.BaseGCPModule

	FoxMapper *foxmapperservice.FoxMapperService
	OrgID     string
	ProjectID string
	DataPath  string
	OrgCache  *gcpinternal.OrgCache

	// Output data
	Admins          []*foxmapperservice.Node
	NodesWithPrivesc []*foxmapperservice.Node
	Summary         map[string]interface{}
	LootMap         map[string]*internal.LootFile

	mu sync.Mutex
}

type FoxMapperOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o FoxMapperOutput) TableFiles() []internal.TableFile { return o.Table }
func (o FoxMapperOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPFoxMapperCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, "foxmapper")
	if err != nil {
		return
	}

	module := &FoxMapperModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		FoxMapper:     foxmapperservice.New(),
		OrgID:         foxmapperOrgID,
		ProjectID:     foxmapperProjectID,
		DataPath:      foxmapperDataPath,
		LootMap:       make(map[string]*internal.LootFile),
	}

	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *FoxMapperModule) Execute(ctx context.Context, logger internal.Logger) {
	// Get OrgCache for project number resolution
	m.OrgCache = gcpinternal.GetOrgCacheFromContext(ctx)

	logger.InfoM("Looking for FoxMapper data and building privilege escalation graph...", "foxmapper")

	// Custom path specified - load directly
	if m.DataPath != "" {
		if err := m.FoxMapper.LoadGraphFromPath(m.DataPath); err != nil {
			logger.ErrorM(fmt.Sprintf("Failed to load FoxMapper data from path: %v", err), "foxmapper")
			return
		}
		m.analyzeAndOutput(ctx, logger, m.DataPath)
		return
	}

	// Specific org specified
	if m.OrgID != "" {
		if err := m.FoxMapper.LoadGraph(m.OrgID, true); err != nil {
			logger.ErrorM(fmt.Sprintf("Failed to load FoxMapper data for org %s: %v", m.OrgID, err), "foxmapper")
			fmt.Printf("\nTo generate FoxMapper data, run:\n  foxmapper gcp graph create --org %s\n", m.OrgID)
			return
		}
		m.analyzeAndOutput(ctx, logger, m.OrgID)
		return
	}

	// Specific project specified via module flag
	if m.ProjectID != "" {
		if err := m.FoxMapper.LoadGraph(m.ProjectID, false); err != nil {
			logger.ErrorM(fmt.Sprintf("Failed to load FoxMapper data for project %s: %v", m.ProjectID, err), "foxmapper")
			fmt.Printf("\nTo generate FoxMapper data, run:\n  foxmapper gcp graph create --project %s\n", m.ProjectID)
			return
		}
		m.analyzeAndOutput(ctx, logger, m.ProjectID)
		return
	}

	// No specific identifier - try org from hierarchy, then iterate projects
	orgID := ""
	if m.Hierarchy != nil && len(m.Hierarchy.Organizations) > 0 {
		orgID = m.Hierarchy.Organizations[0].ID
	}

	// Try org-level graph first (covers all projects)
	if orgID != "" {
		if err := m.FoxMapper.LoadGraph(orgID, true); err == nil {
			logger.InfoM(fmt.Sprintf("Loaded org-level FoxMapper graph for org: %s", orgID), "foxmapper")
			m.analyzeAndOutput(ctx, logger, orgID)
			return
		}
	}

	// No org graph - try each project
	if len(m.ProjectIDs) == 0 {
		logger.ErrorM("No organization or project specified. Use --org or --project flag.", "foxmapper")
		logger.InfoM("To generate FoxMapper data, run:", "foxmapper")
		logger.InfoM("  foxmapper gcp graph create --org {org_id}", "foxmapper")
		logger.InfoM("  foxmapper gcp graph create --project {project_id}", "foxmapper")
		return
	}

	// Build hierarchical output for per-project analysis
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	foundAny := false
	for _, projectID := range m.ProjectIDs {
		// Create fresh FoxMapper service for each project
		projectFM := foxmapperservice.New()
		if err := projectFM.LoadGraph(projectID, false); err != nil {
			// No FoxMapper data for this project - skip silently
			continue
		}

		foundAny = true
		logger.InfoM(fmt.Sprintf("Loaded FoxMapper graph for project %s: %d nodes, %d edges",
			projectID, len(projectFM.Nodes), len(projectFM.Edges)), "foxmapper")

		// Analyze this project
		admins := projectFM.GetAdminNodes()
		nodesWithPrivesc := projectFM.GetNodesWithPrivesc()
		summary := projectFM.GetPrivescSummary()

		// Generate output for this project
		output := m.generateOutputForProject(logger, projectID, projectFM, admins, nodesWithPrivesc, summary)
		outputData.ProjectLevelData[projectID] = output

		// Print summary for this project
		m.printProjectSummary(logger, projectID, summary)
	}

	if !foundAny {
		logger.ErrorM("No FoxMapper data found for any project.", "foxmapper")
		fmt.Println("\nTo generate FoxMapper data, run:")
		fmt.Println("  foxmapper gcp graph create --org {org_id}")
		fmt.Println("  foxmapper gcp graph create --project {project_id}")
		fmt.Println("\nFor more info: https://github.com/BishopFox/cloudfox/wiki/GCP-Commands#foxmapper")
		return
	}

	// Write hierarchical output
	pathBuilder := m.BuildPathBuilder()
	if err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData); err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), "foxmapper")
	}
}

// analyzeAndOutput analyzes a single loaded FoxMapper graph and writes output
func (m *FoxMapperModule) analyzeAndOutput(ctx context.Context, logger internal.Logger, identifier string) {
	logger.InfoM(fmt.Sprintf("Loaded FoxMapper graph: %d nodes, %d edges",
		len(m.FoxMapper.Nodes), len(m.FoxMapper.Edges)), "foxmapper")

	// Get analysis data
	m.Admins = m.FoxMapper.GetAdminNodes()
	m.NodesWithPrivesc = m.FoxMapper.GetNodesWithPrivesc()
	m.Summary = m.FoxMapper.GetPrivescSummary()

	// Generate output
	output := m.generateOutput(logger, identifier)

	// For org-level or single identifier, use hierarchical output at org level
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}
	outputData.OrgLevelData[identifier] = output

	pathBuilder := m.BuildPathBuilder()
	if err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData); err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), "foxmapper")
	}

	// Print summary
	m.printSummary(logger, identifier)
}

// generateOutputForProject generates output for a specific project's FoxMapper data
func (m *FoxMapperModule) generateOutputForProject(logger internal.Logger, projectID string, fm *foxmapperservice.FoxMapperService, admins []*foxmapperservice.Node, nodesWithPrivesc []*foxmapperservice.Node, summary map[string]interface{}) FoxMapperOutput {
	var output FoxMapperOutput

	// Main table: principals with admin or path to admin
	// Read left to right: Project -> Type -> Principal -> Admin Status -> Privesc Target -> Privesc Admin Level -> Hops
	mainHeader := []string{"Project", "Type", "Principal", "Is Admin", "Admin Level", "Privesc To", "Privesc Admin Level", "Hops", "Confidence"}
	var mainBody [][]string

	// First add admins
	for _, admin := range admins {
		adminLevel := admin.AdminLevel
		if adminLevel == "" {
			adminLevel = "project"
		}
		mainBody = append(mainBody, []string{
			admin.ProjectID,
			admin.MemberType,
			admin.Email,
			"Yes",
			adminLevel,
			"-",
			"-",
			"-",
			"-",
		})
	}

	// Then add nodes with privesc paths
	for _, node := range nodesWithPrivesc {
		paths := fm.GetPrivescPaths(node.Email)
		shortestPath := "-"
		privescTo := "-"
		privescAdminLevel := "-"
		confidence := "-"
		if len(paths) > 0 {
			bestPath := paths[0]
			shortestPath = strconv.Itoa(bestPath.HopCount)
			// Get the destination (admin) from the best path
			privescTo = bestPath.Destination
			// Clean up the display
			if strings.HasPrefix(privescTo, "serviceAccount:") {
				privescTo = strings.TrimPrefix(privescTo, "serviceAccount:")
			} else if strings.HasPrefix(privescTo, "user:") {
				privescTo = strings.TrimPrefix(privescTo, "user:")
			}

			// Confidence from the best path
			confidence = bestPath.Confidence
			if confidence == "" {
				confidence = "high"
			}

			// Format privesc admin level
			destNode := fm.GetNode(bestPath.Destination)
			switch bestPath.AdminLevel {
			case "org":
				privescAdminLevel = "Org"
			case "folder":
				// Try to extract folder from the destination node's IAM bindings
				if destNode != nil && len(destNode.IAMBindings) > 0 {
					for _, binding := range destNode.IAMBindings {
						if resource, ok := binding["resource"].(string); ok {
							if strings.HasPrefix(resource, "folders/") {
								folderID := strings.TrimPrefix(resource, "folders/")
								privescAdminLevel = fmt.Sprintf("Folder: %s", folderID)
								break
							}
						}
					}
				}
				if privescAdminLevel == "-" {
					privescAdminLevel = "Folder"
				}
			case "project":
				// Try to get the project ID from the destination node or principal
				if destNode != nil && destNode.ProjectID != "" {
					privescAdminLevel = fmt.Sprintf("Project: %s", destNode.ProjectID)
				} else {
					destProject := extractProjectFromPrincipal(bestPath.Destination, m.OrgCache)
					if destProject != "" {
						privescAdminLevel = fmt.Sprintf("Project: %s", destProject)
					} else {
						privescAdminLevel = "Project"
					}
				}
			default:
				if bestPath.AdminLevel != "" {
					privescAdminLevel = bestPath.AdminLevel
				}
			}
		}
		mainBody = append(mainBody, []string{
			node.ProjectID,
			node.MemberType,
			node.Email,
			"No",
			"-",
			privescTo,
			privescAdminLevel,
			shortestPath,
			confidence,
		})
	}

	output.Table = append(output.Table, internal.TableFile{
		Header: mainHeader,
		Body:   mainBody,
		Name:   "foxmapper",
	})

	// Loot file - summary
	lootContent := m.generateLootContentForProject(projectID, fm, admins, nodesWithPrivesc, summary)
	output.Loot = append(output.Loot, internal.LootFile{
		Name:     "foxmapper",
		Contents: lootContent,
	})

	// Loot file - detailed paths (paths go to loot only, not table/csv/json)
	pathsLootContent := m.generatePathsLootContentForProject(projectID, fm, nodesWithPrivesc)
	output.Loot = append(output.Loot, internal.LootFile{
		Name:     "foxmapper-paths",
		Contents: pathsLootContent,
	})

	return output
}

// generatePathsLootContentForProject generates detailed paths loot for a specific project
func (m *FoxMapperModule) generatePathsLootContentForProject(projectID string, fm *foxmapperservice.FoxMapperService, nodesWithPrivesc []*foxmapperservice.Node) string {
	var sb strings.Builder

	sb.WriteString("# FoxMapper Privilege Escalation Paths\n")
	sb.WriteString(fmt.Sprintf("# Project: %s\n", projectID))
	sb.WriteString(fmt.Sprintf("# Total paths: %d principals with escalation paths\n\n", len(nodesWithPrivesc)))

	for _, node := range nodesWithPrivesc {
		paths := fm.GetPrivescPaths(node.Email)
		if len(paths) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("================================================================================\n"))
		sb.WriteString(fmt.Sprintf("SOURCE: %s (%s)\n", node.Email, node.MemberType))
		sb.WriteString(fmt.Sprintf("Project: %s\n", node.ProjectID))
		sb.WriteString(fmt.Sprintf("Escalation paths: %d\n", len(paths)))
		sb.WriteString(fmt.Sprintf("================================================================================\n\n"))

		for pathIdx, path := range paths {
			scopeStatus := ""
			if path.ScopeBlocked {
				scopeStatus = " [SCOPE-BLOCKED]"
			}
			confidenceStatus := ""
			if path.Confidence != "" && path.Confidence != "high" {
				confidenceStatus = fmt.Sprintf(" [%s confidence]", path.Confidence)
			}

			sb.WriteString(fmt.Sprintf("--- Path %d: %s → %s (%s admin, %d hops)%s%s ---\n\n",
				pathIdx+1, path.Source, path.Destination, path.AdminLevel, path.HopCount, scopeStatus, confidenceStatus))

			// Show the path as a visual chain
			sb.WriteString(fmt.Sprintf("  %s\n", path.Source))
			for i, edge := range path.Edges {
				sb.WriteString("    │\n")

				annotations := ""
				if edge.ScopeBlocksEscalation {
					annotations = " ⚠️  BLOCKED BY OAUTH SCOPE"
				} else if edge.ScopeLimited {
					annotations = " ⚠️  scope-limited"
				}
				edgeConf := edge.EffectiveConfidence()
				if edgeConf != "high" {
					annotations += fmt.Sprintf(" [%s confidence]", edgeConf)
				}

				sb.WriteString(fmt.Sprintf("    ├── [%d] %s%s\n", i+1, edge.ShortReason, annotations))

				if edge.Resource != "" {
					sb.WriteString(fmt.Sprintf("    │       Resource: %s\n", edge.Resource))
				}

				if edge.Reason != "" && edge.Reason != edge.ShortReason {
					reason := edge.Reason
					if len(reason) > 80 {
						sb.WriteString(fmt.Sprintf("    │       %s\n", reason[:80]))
						sb.WriteString(fmt.Sprintf("    │       %s\n", reason[80:]))
					} else {
						sb.WriteString(fmt.Sprintf("    │       %s\n", reason))
					}
				}

				if i < len(path.Edges)-1 {
					sb.WriteString(fmt.Sprintf("    │\n"))
					sb.WriteString(fmt.Sprintf("    ▼\n"))
					sb.WriteString(fmt.Sprintf("  %s\n", edge.Destination))
				} else {
					sb.WriteString(fmt.Sprintf("    │\n"))
					sb.WriteString(fmt.Sprintf("    └──▶ %s (ADMIN)\n", edge.Destination))
				}
			}
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// generateLootContentForProject generates loot content for a specific project
func (m *FoxMapperModule) generateLootContentForProject(projectID string, fm *foxmapperservice.FoxMapperService, admins []*foxmapperservice.Node, nodesWithPrivesc []*foxmapperservice.Node, summary map[string]interface{}) string {
	var sb strings.Builder

	sb.WriteString("=== FoxMapper Privilege Escalation Analysis ===\n\n")
	sb.WriteString(fmt.Sprintf("Project: %s\n", projectID))
	sb.WriteString(fmt.Sprintf("Total Nodes: %d\n", summary["total_nodes"]))
	sb.WriteString(fmt.Sprintf("Admin Nodes: %d\n", summary["admin_nodes"]))
	sb.WriteString(fmt.Sprintf("Nodes with Privesc: %d\n", summary["nodes_with_privesc"]))
	sb.WriteString(fmt.Sprintf("Percent with Privesc: %.1f%%\n\n", summary["percent_with_privesc"]))

	// Admin breakdown
	sb.WriteString("=== Admin Breakdown ===\n")
	sb.WriteString(fmt.Sprintf("  Organization Admins: %d\n", summary["org_admins"]))
	sb.WriteString(fmt.Sprintf("  Folder Admins: %d\n", summary["folder_admins"]))
	sb.WriteString(fmt.Sprintf("  Project Admins: %d\n\n", summary["project_admins"]))

	// List admins
	sb.WriteString("=== Admin Principals ===\n")
	for _, admin := range admins {
		adminLevel := admin.AdminLevel
		if adminLevel == "" {
			adminLevel = "project"
		}
		sb.WriteString(fmt.Sprintf("ADMIN (%s): %s\n", adminLevel, admin.Email))
	}
	sb.WriteString("\n")

	// List privesc paths
	sb.WriteString("=== Privilege Escalation Paths ===\n\n")
	for _, node := range nodesWithPrivesc {
		paths := fm.GetPrivescPaths(node.Email)
		for _, path := range paths {
			sb.WriteString(fmt.Sprintf("PATH TO %s ADMIN FOUND\n", strings.ToUpper(path.AdminLevel)))
			sb.WriteString(fmt.Sprintf("  Start: %s\n", path.Source))
			sb.WriteString(fmt.Sprintf("  End:   %s\n", path.Destination))
			sb.WriteString(fmt.Sprintf("  Hops:  %d\n", path.HopCount))
			if path.Confidence != "" && path.Confidence != "high" {
				sb.WriteString(fmt.Sprintf("  Confidence: %s\n", path.Confidence))
			}
			if path.ScopeBlocked {
				sb.WriteString("  WARNING: Path may be blocked by OAuth scopes\n")
			}
			sb.WriteString("  Path:\n")
			for i, edge := range path.Edges {
				annotations := ""
				if edge.ScopeBlocksEscalation {
					annotations = " [BLOCKED BY SCOPE]"
				} else if edge.ScopeLimited {
					annotations = " [scope-limited]"
				}
				edgeConf := edge.EffectiveConfidence()
				if edgeConf != "high" {
					annotations += fmt.Sprintf(" [%s confidence]", edgeConf)
				}
				sb.WriteString(fmt.Sprintf("    (%d) %s%s\n", i+1, edge.Reason, annotations))
			}
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// printProjectSummary prints a summary for a single project
func (m *FoxMapperModule) printProjectSummary(logger internal.Logger, projectID string, summary map[string]interface{}) {
	totalNodes, _ := summary["total_nodes"].(int)
	adminNodes, _ := summary["admin_nodes"].(int)
	nodesWithPrivesc, _ := summary["nodes_with_privesc"].(int)

	logger.InfoM(fmt.Sprintf("[%s] %d principals, %d admins, %d with privesc path",
		projectID, totalNodes, adminNodes, nodesWithPrivesc), "foxmapper")
}

func (m *FoxMapperModule) generateOutput(logger internal.Logger, identifier string) FoxMapperOutput {
	var output FoxMapperOutput

	// Main table: principals with admin or path to admin
	// Read left to right: Project -> Type -> Principal -> Admin Status -> Privesc Target -> Privesc Admin Level -> Hops
	mainHeader := []string{"Project", "Type", "Principal", "Is Admin", "Admin Level", "Privesc To", "Privesc Admin Level", "Hops", "Confidence"}
	var mainBody [][]string

	// First add admins
	for _, admin := range m.Admins {
		adminLevel := admin.AdminLevel
		if adminLevel == "" {
			adminLevel = "project"
		}
		mainBody = append(mainBody, []string{
			admin.ProjectID,
			admin.MemberType,
			admin.Email,
			"Yes",
			adminLevel,
			"-",
			"-",
			"-",
			"-",
		})
	}

	// Then add nodes with privesc paths
	for _, node := range m.NodesWithPrivesc {
		paths := m.FoxMapper.GetPrivescPaths(node.Email)
		shortestPath := "-"
		privescTo := "-"
		privescAdminLevel := "-"
		confidence := "-"
		if len(paths) > 0 {
			bestPath := paths[0]
			shortestPath = strconv.Itoa(bestPath.HopCount)
			// Get the destination (admin) from the best path
			privescTo = bestPath.Destination
			// Clean up the display
			if strings.HasPrefix(privescTo, "serviceAccount:") {
				privescTo = strings.TrimPrefix(privescTo, "serviceAccount:")
			} else if strings.HasPrefix(privescTo, "user:") {
				privescTo = strings.TrimPrefix(privescTo, "user:")
			}

			// Confidence from the best path
			confidence = bestPath.Confidence
			if confidence == "" {
				confidence = "high"
			}

			// Format privesc admin level
			destNode := m.FoxMapper.GetNode(bestPath.Destination)
			switch bestPath.AdminLevel {
			case "org":
				privescAdminLevel = "Org"
			case "folder":
				// Try to extract folder from the destination node's IAM bindings
				if destNode != nil && len(destNode.IAMBindings) > 0 {
					for _, binding := range destNode.IAMBindings {
						if resource, ok := binding["resource"].(string); ok {
							if strings.HasPrefix(resource, "folders/") {
								folderID := strings.TrimPrefix(resource, "folders/")
								privescAdminLevel = fmt.Sprintf("Folder: %s", folderID)
								break
							}
						}
					}
				}
				if privescAdminLevel == "-" {
					privescAdminLevel = "Folder"
				}
			case "project":
				// Try to get the project ID from the destination node or principal
				if destNode != nil && destNode.ProjectID != "" {
					privescAdminLevel = fmt.Sprintf("Project: %s", destNode.ProjectID)
				} else {
					destProject := extractProjectFromPrincipal(bestPath.Destination, m.OrgCache)
					if destProject != "" {
						privescAdminLevel = fmt.Sprintf("Project: %s", destProject)
					} else {
						privescAdminLevel = "Project"
					}
				}
			default:
				if bestPath.AdminLevel != "" {
					privescAdminLevel = bestPath.AdminLevel
				}
			}
		}
		mainBody = append(mainBody, []string{
			node.ProjectID,
			node.MemberType,
			node.Email,
			"No",
			"-",
			privescTo,
			privescAdminLevel,
			shortestPath,
			confidence,
		})
	}

	output.Table = append(output.Table, internal.TableFile{
		Header: mainHeader,
		Body:   mainBody,
		Name:   "foxmapper",
	})

	// Detailed paths loot file with full exploitation steps (paths go to loot only, not table/csv/json)
	pathsLootContent := m.generatePathsLootContent(identifier)
	output.Loot = append(output.Loot, internal.LootFile{
		Name:     "foxmapper-paths",
		Contents: pathsLootContent,
	})

	// Loot file with full details
	lootContent := m.generateLootContent(identifier)
	output.Loot = append(output.Loot, internal.LootFile{
		Name:     "foxmapper",
		Contents: lootContent,
	})

	return output
}

func (m *FoxMapperModule) generatePathsLootContent(identifier string) string {
	var sb strings.Builder

	sb.WriteString("# FoxMapper Privilege Escalation Paths\n")
	sb.WriteString(fmt.Sprintf("# Identifier: %s\n", identifier))
	sb.WriteString(fmt.Sprintf("# Total paths: %d principals with escalation paths\n\n", len(m.NodesWithPrivesc)))

	for _, node := range m.NodesWithPrivesc {
		paths := m.FoxMapper.GetPrivescPaths(node.Email)
		if len(paths) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("================================================================================\n"))
		sb.WriteString(fmt.Sprintf("SOURCE: %s (%s)\n", node.Email, node.MemberType))
		sb.WriteString(fmt.Sprintf("Project: %s\n", node.ProjectID))
		sb.WriteString(fmt.Sprintf("Escalation paths: %d\n", len(paths)))
		sb.WriteString(fmt.Sprintf("================================================================================\n\n"))

		for pathIdx, path := range paths {
			scopeStatus := ""
			if path.ScopeBlocked {
				scopeStatus = " [SCOPE-BLOCKED]"
			}

			sb.WriteString(fmt.Sprintf("--- Path %d: %s → %s (%s admin, %d hops)%s ---\n\n",
				pathIdx+1, path.Source, path.Destination, path.AdminLevel, path.HopCount, scopeStatus))

			// Show the path as a visual chain
			sb.WriteString(fmt.Sprintf("  %s\n", path.Source))
			for i, edge := range path.Edges {
				// Connector
				if i < len(path.Edges)-1 {
					sb.WriteString("    │\n")
				} else {
					sb.WriteString("    │\n")
				}

				// Scope warning
				scopeWarning := ""
				if edge.ScopeBlocksEscalation {
					scopeWarning = " ⚠️  BLOCKED BY OAUTH SCOPE"
				} else if edge.ScopeLimited {
					scopeWarning = " ⚠️  scope-limited"
				}

				// The technique/reason
				sb.WriteString(fmt.Sprintf("    ├── [%d] %s%s\n", i+1, edge.ShortReason, scopeWarning))

				// Resource if available
				if edge.Resource != "" {
					sb.WriteString(fmt.Sprintf("    │       Resource: %s\n", edge.Resource))
				}

				// Full reason/description
				if edge.Reason != "" && edge.Reason != edge.ShortReason {
					// Wrap long reasons
					reason := edge.Reason
					if len(reason) > 80 {
						sb.WriteString(fmt.Sprintf("    │       %s\n", reason[:80]))
						sb.WriteString(fmt.Sprintf("    │       %s\n", reason[80:]))
					} else {
						sb.WriteString(fmt.Sprintf("    │       %s\n", reason))
					}
				}

				// Show destination after this hop
				if i < len(path.Edges)-1 {
					sb.WriteString(fmt.Sprintf("    │\n"))
					sb.WriteString(fmt.Sprintf("    ▼\n"))
					sb.WriteString(fmt.Sprintf("  %s\n", edge.Destination))
				} else {
					sb.WriteString(fmt.Sprintf("    │\n"))
					sb.WriteString(fmt.Sprintf("    └──▶ %s (ADMIN)\n", edge.Destination))
				}
			}
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

func (m *FoxMapperModule) generateLootContent(identifier string) string {
	var sb strings.Builder

	sb.WriteString("=== FoxMapper Privilege Escalation Analysis ===\n\n")
	sb.WriteString(fmt.Sprintf("Identifier: %s\n", identifier))
	sb.WriteString(fmt.Sprintf("Total Nodes: %d\n", m.Summary["total_nodes"]))
	sb.WriteString(fmt.Sprintf("Admin Nodes: %d\n", m.Summary["admin_nodes"]))
	sb.WriteString(fmt.Sprintf("Nodes with Privesc: %d\n", m.Summary["nodes_with_privesc"]))
	sb.WriteString(fmt.Sprintf("Percent with Privesc: %.1f%%\n\n", m.Summary["percent_with_privesc"]))

	// Admin breakdown
	sb.WriteString("=== Admin Breakdown ===\n")
	sb.WriteString(fmt.Sprintf("  Organization Admins: %d\n", m.Summary["org_admins"]))
	sb.WriteString(fmt.Sprintf("  Folder Admins: %d\n", m.Summary["folder_admins"]))
	sb.WriteString(fmt.Sprintf("  Project Admins: %d\n\n", m.Summary["project_admins"]))

	// List admins
	sb.WriteString("=== Admin Principals ===\n")
	for _, admin := range m.Admins {
		adminLevel := admin.AdminLevel
		if adminLevel == "" {
			adminLevel = "project"
		}
		sb.WriteString(fmt.Sprintf("ADMIN (%s): %s\n", adminLevel, admin.Email))
	}
	sb.WriteString("\n")

	// List privesc paths
	sb.WriteString("=== Privilege Escalation Paths ===\n\n")
	for _, node := range m.NodesWithPrivesc {
		paths := m.FoxMapper.GetPrivescPaths(node.Email)
		for _, path := range paths {
			sb.WriteString(fmt.Sprintf("PATH TO %s ADMIN FOUND\n", strings.ToUpper(path.AdminLevel)))
			sb.WriteString(fmt.Sprintf("  Start: %s\n", path.Source))
			sb.WriteString(fmt.Sprintf("  End:   %s\n", path.Destination))
			sb.WriteString(fmt.Sprintf("  Hops:  %d\n", path.HopCount))
			if path.Confidence != "" && path.Confidence != "high" {
				sb.WriteString(fmt.Sprintf("  Confidence: %s\n", path.Confidence))
			}
			if path.ScopeBlocked {
				sb.WriteString("  WARNING: Path may be blocked by OAuth scopes\n")
			}
			sb.WriteString("  Path:\n")
			for i, edge := range path.Edges {
				annotations := ""
				if edge.ScopeBlocksEscalation {
					annotations = " [BLOCKED BY SCOPE]"
				} else if edge.ScopeLimited {
					annotations = " [scope-limited]"
				}
				edgeConf := edge.EffectiveConfidence()
				if edgeConf != "high" {
					annotations += fmt.Sprintf(" [%s confidence]", edgeConf)
				}
				sb.WriteString(fmt.Sprintf("    (%d) %s%s\n", i+1, edge.Reason, annotations))
			}
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

func (m *FoxMapperModule) printSummary(logger internal.Logger, identifier string) {
	totalNodes, _ := m.Summary["total_nodes"].(int)
	adminNodes, _ := m.Summary["admin_nodes"].(int)
	nodesWithPrivesc, _ := m.Summary["nodes_with_privesc"].(int)

	logger.InfoM(fmt.Sprintf("Analysis complete for: %s", identifier), "foxmapper")
	logger.InfoM(fmt.Sprintf("Total principals: %d", totalNodes), "foxmapper")
	logger.InfoM(fmt.Sprintf("Admin principals: %d", adminNodes), "foxmapper")
	logger.InfoM(fmt.Sprintf("Principals with path to admin: %d", nodesWithPrivesc), "foxmapper")

	if nodesWithPrivesc > 0 {
		percent, _ := m.Summary["percent_with_privesc"].(float64)
		logger.InfoM(fmt.Sprintf("Percent with privesc: %.1f%%", percent), "foxmapper")
	}

	// Output file location
	outputDir := filepath.Join(m.OutputDirectory, "cloudfox-output", "gcp", m.Account)
	logger.InfoM(fmt.Sprintf("Output written to: %s", outputDir), "foxmapper")
	logger.InfoM("For detailed paths, see the loot file: foxmapper.txt", "foxmapper")
}

// ============================================================================
// FoxMapper Cache for use by other modules
// ============================================================================

// FoxMapperCache wraps FoxMapperService for use by other modules
type FoxMapperCache struct {
	service    *foxmapperservice.FoxMapperService
	populated  bool
	identifier string
}

// NewFoxMapperCache creates a new FoxMapper cache
func NewFoxMapperCache() *FoxMapperCache {
	return &FoxMapperCache{
		service: foxmapperservice.New(),
	}
}

// LoadFromOrg loads FoxMapper data for an organization
func (c *FoxMapperCache) LoadFromOrg(orgID string) error {
	err := c.service.LoadGraph(orgID, true)
	if err != nil {
		return err
	}
	c.populated = true
	c.identifier = orgID
	return nil
}

// LoadFromProject loads FoxMapper data for a project
func (c *FoxMapperCache) LoadFromProject(projectID string) error {
	err := c.service.LoadGraph(projectID, false)
	if err != nil {
		return err
	}
	c.populated = true
	c.identifier = projectID
	return nil
}

// LoadFromPath loads FoxMapper data from a custom path
func (c *FoxMapperCache) LoadFromPath(path string) error {
	err := c.service.LoadGraphFromPath(path)
	if err != nil {
		return err
	}
	c.populated = true
	c.identifier = path
	return nil
}

// TryLoad attempts to load FoxMapper data, trying org first then project
func (c *FoxMapperCache) TryLoad(orgID, projectID string) error {
	// Try org first
	if orgID != "" {
		if err := c.LoadFromOrg(orgID); err == nil {
			return nil
		}
	}
	// Try project
	if projectID != "" {
		if err := c.LoadFromProject(projectID); err == nil {
			return nil
		}
	}
	return fmt.Errorf("could not load FoxMapper data for org %s or project %s", orgID, projectID)
}

// IsPopulated returns whether the cache has data
func (c *FoxMapperCache) IsPopulated() bool {
	return c.populated
}

// GetAttackSummary returns attack path summary for a principal
func (c *FoxMapperCache) GetAttackSummary(principal string) string {
	if !c.populated {
		return "run foxmapper"
	}
	return c.service.GetAttackSummary(principal)
}

// DoesPrincipalHavePathToAdmin checks if principal can escalate
func (c *FoxMapperCache) DoesPrincipalHavePathToAdmin(principal string) bool {
	if !c.populated {
		return false
	}
	return c.service.DoesPrincipalHavePathToAdmin(principal)
}

// IsPrincipalAdmin checks if principal is admin
func (c *FoxMapperCache) IsPrincipalAdmin(principal string) bool {
	if !c.populated {
		return false
	}
	return c.service.IsPrincipalAdmin(principal)
}

// GetPrivescPaths returns privesc paths for a principal
func (c *FoxMapperCache) GetPrivescPaths(principal string) []foxmapperservice.PrivescPath {
	if !c.populated {
		return nil
	}
	return c.service.GetPrivescPaths(principal)
}

// GetService returns the underlying FoxMapper service
func (c *FoxMapperCache) GetService() *foxmapperservice.FoxMapperService {
	return c.service
}

// ============================================================================
// Helper to find and load FoxMapper data
// ============================================================================

// FindAndLoadFoxMapper attempts to find and load FoxMapper data
// Returns the loaded cache or nil if not found
func FindAndLoadFoxMapper(orgID string, projectIDs []string, logger internal.Logger) *FoxMapperCache {
	cache := NewFoxMapperCache()

	// Try org first
	if orgID != "" {
		if err := cache.LoadFromOrg(orgID); err == nil {
			logger.InfoM(fmt.Sprintf("Loaded FoxMapper data for org: %s", orgID), "foxmapper")
			return cache
		}
	}

	// Try each project
	for _, projectID := range projectIDs {
		if err := cache.LoadFromProject(projectID); err == nil {
			logger.InfoM(fmt.Sprintf("Loaded FoxMapper data for project: %s", projectID), "foxmapper")
			return cache
		}
	}

	return nil
}

// SortNodesByPrivesc sorts nodes by privesc capability for display
func SortNodesByPrivesc(nodes []*foxmapperservice.Node) {
	sort.Slice(nodes, func(i, j int) bool {
		// Admins first
		if nodes[i].IsAdmin && !nodes[j].IsAdmin {
			return true
		}
		if !nodes[i].IsAdmin && nodes[j].IsAdmin {
			return false
		}
		// Then by admin level (org > folder > project)
		levelOrder := map[string]int{"org": 0, "folder": 1, "project": 2, "": 3}
		if nodes[i].AdminLevel != nodes[j].AdminLevel {
			return levelOrder[nodes[i].AdminLevel] < levelOrder[nodes[j].AdminLevel]
		}
		// Then by email
		return nodes[i].Email < nodes[j].Email
	})
}
