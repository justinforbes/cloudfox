package commands

import (
	"context"
	"fmt"
	"strings"

	accesspolicyservice "github.com/BishopFox/cloudfox/gcp/services/accessPolicyService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
	cloudresourcemanager "google.golang.org/api/cloudresourcemanager/v1"
)

var accessLevelOrgID string

var GCPAccessLevelsCommand = &cobra.Command{
	Use:     globals.GCP_ACCESSLEVELS_MODULE_NAME,
	Aliases: []string{"access-levels", "conditional-access", "ca"},
	Short:   "Enumerate Access Context Manager access levels",
	Long: `Enumerate Access Context Manager access levels (conditional access policies).

Features:
- Lists all access levels in the organization
- Shows IP-based, device-based, and identity conditions
- Identifies overly permissive access levels
- Analyzes device policy requirements

Organization Discovery:
- Automatically discovers organization from project ancestry if --org not specified
- Use --org to explicitly specify an organization ID`,
	Run: runGCPAccessLevelsCommand,
}

func init() {
	GCPAccessLevelsCommand.Flags().StringVar(&accessLevelOrgID, "org", "", "Organization ID (required)")
}

type AccessLevelsModule struct {
	gcpinternal.BaseGCPModule
	OrgID        string
	AccessLevels []accesspolicyservice.AccessLevelInfo
	LootMap      map[string]*internal.LootFile
}

type AccessLevelsOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o AccessLevelsOutput) TableFiles() []internal.TableFile { return o.Table }
func (o AccessLevelsOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPAccessLevelsCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_ACCESSLEVELS_MODULE_NAME)
	if err != nil {
		return
	}

	// Discover organizations if not specified
	orgIDs := []string{}
	if accessLevelOrgID != "" {
		orgIDs = append(orgIDs, accessLevelOrgID)
	} else {
		// Auto-discover organizations from project ancestry
		discoveredOrgs := discoverOrganizations(cmdCtx.Ctx, cmdCtx.ProjectIDs, cmdCtx.Logger)
		if len(discoveredOrgs) == 0 {
			cmdCtx.Logger.ErrorM("Could not discover any organizations. Use --org flag to specify one.", globals.GCP_ACCESSLEVELS_MODULE_NAME)
			return
		}
		orgIDs = discoveredOrgs
		cmdCtx.Logger.InfoM(fmt.Sprintf("Discovered %d organization(s) from project ancestry", len(orgIDs)), globals.GCP_ACCESSLEVELS_MODULE_NAME)
	}

	// Run for each organization
	for _, orgID := range orgIDs {
		module := &AccessLevelsModule{
			BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
			OrgID:         orgID,
			AccessLevels:  []accesspolicyservice.AccessLevelInfo{},
			LootMap:       make(map[string]*internal.LootFile),
		}
		module.initializeLootFiles()
		module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
	}
}

// discoverOrganizations finds organization IDs from project ancestry
func discoverOrganizations(ctx context.Context, projectIDs []string, logger internal.Logger) []string {
	crmService, err := cloudresourcemanager.NewService(ctx)
	if err != nil {
		return nil
	}

	orgMap := make(map[string]bool)
	for _, projectID := range projectIDs {
		resp, err := crmService.Projects.GetAncestry(projectID, &cloudresourcemanager.GetAncestryRequest{}).Do()
		if err != nil {
			continue
		}

		for _, ancestor := range resp.Ancestor {
			if ancestor.ResourceId.Type == "organization" {
				orgMap[ancestor.ResourceId.Id] = true
			}
		}
	}

	var orgs []string
	for orgID := range orgMap {
		orgs = append(orgs, orgID)
	}
	return orgs
}

func (m *AccessLevelsModule) Execute(ctx context.Context, logger internal.Logger) {
	logger.InfoM(fmt.Sprintf("Enumerating access levels for organization: %s", m.OrgID), globals.GCP_ACCESSLEVELS_MODULE_NAME)

	svc := accesspolicyservice.New()

	levels, err := svc.ListAccessLevels(m.OrgID)
	if err != nil {
		// Use shared error handling
		gcpinternal.HandleGCPError(err, logger, globals.GCP_ACCESSLEVELS_MODULE_NAME,
			fmt.Sprintf("Could not list access levels for org %s", m.OrgID))
		return
	}

	m.AccessLevels = levels

	if len(m.AccessLevels) == 0 {
		logger.InfoM("No access levels found", globals.GCP_ACCESSLEVELS_MODULE_NAME)
		return
	}

	for _, level := range m.AccessLevels {
		m.addToLoot(level)
	}

	permissiveCount := 0
	for _, level := range m.AccessLevels {
		if level.RiskLevel == "HIGH" || level.RiskLevel == "MEDIUM" {
			permissiveCount++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d access level(s) (%d potentially permissive)",
		len(m.AccessLevels), permissiveCount), globals.GCP_ACCESSLEVELS_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *AccessLevelsModule) initializeLootFiles() {
	m.LootMap["access-levels"] = &internal.LootFile{
		Name:     "access-levels",
		Contents: "# Access Levels (Conditional Access Policies)\n# Generated by CloudFox\n\n",
	}
	m.LootMap["allowed-ips"] = &internal.LootFile{
		Name:     "access-level-allowed-ips",
		Contents: "",
	}
}

func (m *AccessLevelsModule) addToLoot(level accesspolicyservice.AccessLevelInfo) {
	m.LootMap["access-levels"].Contents += fmt.Sprintf(
		"# Level: %s\n# Title: %s\n# Policy: %s\n# Combining: %s\n# Conditions: %d\n\n",
		level.Name, level.Title, level.PolicyName, level.CombiningFunction, len(level.Conditions))

	for _, condition := range level.Conditions {
		for _, ip := range condition.IPSubnetworks {
			m.LootMap["allowed-ips"].Contents += fmt.Sprintf("%s # %s\n", ip, level.Name)
		}
	}
}

func (m *AccessLevelsModule) writeOutput(ctx context.Context, logger internal.Logger) {
	var tables []internal.TableFile

	// Access Levels table
	header := []string{"Name", "Title", "Policy", "Combining", "Conditions", "Device Policy", "Risk"}
	var body [][]string
	for _, level := range m.AccessLevels {
		hasDevicePolicy := "No"
		for _, cond := range level.Conditions {
			if cond.DevicePolicy != nil {
				hasDevicePolicy = "Yes"
				break
			}
		}

		combiningFunc := level.CombiningFunction
		if combiningFunc == "" {
			combiningFunc = "AND"
		}

		body = append(body, []string{
			level.Name,
			level.Title,
			level.PolicyName,
			combiningFunc,
			fmt.Sprintf("%d", len(level.Conditions)),
			hasDevicePolicy,
			level.RiskLevel,
		})
	}
	tables = append(tables, internal.TableFile{
		Name:   "access-levels",
		Header: header,
		Body:   body,
	})

	// Conditions detail table
	var condBody [][]string
	for _, level := range m.AccessLevels {
		for i, cond := range level.Conditions {
			ipRanges := strings.Join(cond.IPSubnetworks, ", ")
			if len(ipRanges) > 40 {
				ipRanges = ipRanges[:37] + "..."
			}
			if ipRanges == "" {
				ipRanges = "(any)"
			}

			members := strings.Join(cond.Members, ", ")
			if len(members) > 40 {
				members = members[:37] + "..."
			}
			if members == "" {
				members = "(any)"
			}

			regions := strings.Join(cond.Regions, ", ")
			if regions == "" {
				regions = "(any)"
			}

			deviceReqs := "(none)"
			if cond.DevicePolicy != nil {
				var reqs []string
				if cond.DevicePolicy.RequireScreenLock {
					reqs = append(reqs, "screen-lock")
				}
				if cond.DevicePolicy.RequireCorpOwned {
					reqs = append(reqs, "corp-owned")
				}
				if cond.DevicePolicy.RequireAdminApproval {
					reqs = append(reqs, "admin-approval")
				}
				if len(reqs) > 0 {
					deviceReqs = strings.Join(reqs, ", ")
				}
			}

			condBody = append(condBody, []string{
				level.Name,
				fmt.Sprintf("%d", i+1),
				ipRanges,
				members,
				regions,
				deviceReqs,
			})
		}
	}

	if len(condBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "access-level-conditions",
			Header: []string{"Level", "Condition", "IP Ranges", "Members", "Regions", "Device Requirements"},
			Body:   condBody,
		})
	}

	// High-risk findings
	var highRiskBody [][]string
	for _, level := range m.AccessLevels {
		if level.RiskLevel == "HIGH" || level.RiskLevel == "MEDIUM" {
			highRiskBody = append(highRiskBody, []string{
				level.Name,
				level.Title,
				level.RiskLevel,
				strings.Join(level.RiskReasons, "; "),
			})
		}
	}

	if len(highRiskBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "access-level-risks",
			Header: []string{"Name", "Title", "Risk Level", "Reasons"},
			Body:   highRiskBody,
		})
	}

	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# Generated by CloudFox\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	output := AccessLevelsOutput{Table: tables, Loot: lootFiles}

	err := internal.HandleOutputSmart("gcp", m.Format, m.OutputDirectory, m.Verbosity, m.WrapTable,
		"org", []string{m.OrgID}, []string{m.OrgID}, m.Account, output)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_ACCESSLEVELS_MODULE_NAME)
	}
}
