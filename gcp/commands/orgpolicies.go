package commands

import (
	"github.com/BishopFox/cloudfox/gcp/shared"
	"context"
	"fmt"
	"strings"
	"sync"

	orgpolicyservice "github.com/BishopFox/cloudfox/gcp/services/orgpolicyService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPOrgPoliciesCommand = &cobra.Command{
	Use:     globals.GCP_ORGPOLICIES_MODULE_NAME,
	Aliases: []string{"orgpolicy", "policies"},
	Short:   "Enumerate organization policies and identify security weaknesses",
	Long: `Enumerate GCP organization policies to identify security configuration weaknesses.

Organization policies control security constraints across GCP resources. This module
identifies policies that may be misconfigured or weakened, creating security risks.

Security-Relevant Policies Analyzed:
- Domain restrictions (iam.allowedPolicyMemberDomains)
- Service account key controls (iam.disableServiceAccountKeyCreation)
- Workload identity restrictions
- Compute security (Shielded VM, OS Login, external IPs)
- Storage security (public access, uniform access)
- SQL security (public IPs, authorized networks)
- GKE security (public endpoints)
- Resource location restrictions

Risk Indicators:
- AllowAll: Policy allows any value (HIGH risk)
- Wildcard patterns: Overly permissive allowed values
- Unenforced: Security constraint not enabled
- Override: Project overrides parent restrictions`,
	Run: runGCPOrgPoliciesCommand,
}

type OrgPoliciesModule struct {
	gcpinternal.BaseGCPModule
	ProjectPolicies map[string][]orgpolicyservice.OrgPolicyInfo // projectID -> policies
	LootMap         map[string]map[string]*internal.LootFile    // projectID -> loot files
	mu              sync.Mutex
}

type OrgPoliciesOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o OrgPoliciesOutput) TableFiles() []internal.TableFile { return o.Table }
func (o OrgPoliciesOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPOrgPoliciesCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_ORGPOLICIES_MODULE_NAME)
	if err != nil {
		return
	}

	module := &OrgPoliciesModule{
		BaseGCPModule:   gcpinternal.NewBaseGCPModule(cmdCtx),
		ProjectPolicies: make(map[string][]orgpolicyservice.OrgPolicyInfo),
		LootMap:         make(map[string]map[string]*internal.LootFile),
	}
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *OrgPoliciesModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_ORGPOLICIES_MODULE_NAME, m.processProject)

	allPolicies := m.getAllPolicies()
	if len(allPolicies) == 0 {
		logger.InfoM("No organization policies found (may require orgpolicy.policies.list permission)", globals.GCP_ORGPOLICIES_MODULE_NAME)
		return
	}

	logger.SuccessM(fmt.Sprintf("Found %d organization policy(ies)", len(allPolicies)), globals.GCP_ORGPOLICIES_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *OrgPoliciesModule) getAllPolicies() []orgpolicyservice.OrgPolicyInfo {
	var all []orgpolicyservice.OrgPolicyInfo
	for _, policies := range m.ProjectPolicies {
		all = append(all, policies...)
	}
	return all
}

func (m *OrgPoliciesModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating org policies in project: %s", projectID), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}

	m.mu.Lock()
	if m.LootMap[projectID] == nil {
		m.LootMap[projectID] = make(map[string]*internal.LootFile)
		m.LootMap[projectID]["orgpolicies-commands"] = &internal.LootFile{
			Name:     "orgpolicies-commands",
			Contents: "# Organization Policy Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
		}
	}
	m.mu.Unlock()

	svc := orgpolicyservice.New()
	policies, err := svc.ListProjectPolicies(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_ORGPOLICIES_MODULE_NAME,
			fmt.Sprintf("Could not enumerate org policies in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.ProjectPolicies[projectID] = policies
	for _, policy := range policies {
		m.addPolicyToLoot(projectID, policy)
	}
	m.mu.Unlock()
}

func (m *OrgPoliciesModule) addPolicyToLoot(projectID string, policy orgpolicyservice.OrgPolicyInfo) {
	lootFile := m.LootMap[projectID]["orgpolicies-commands"]
	if lootFile == nil {
		return
	}
	// Extract short constraint name for commands
	constraintName := policy.Constraint
	if strings.HasPrefix(constraintName, "constraints/") {
		constraintName = strings.TrimPrefix(constraintName, "constraints/")
	}

	lootFile.Contents += fmt.Sprintf(
		"## Constraint: %s (Project: %s)\n",
		policy.Constraint, policy.ProjectID,
	)

	if policy.Description != "" {
		lootFile.Contents += fmt.Sprintf("# Description: %s\n", policy.Description)
	}

	lootFile.Contents += fmt.Sprintf(
		"# Enforced: %s, AllowAll: %s, DenyAll: %s, Inherit: %s\n",
		shared.BoolToYesNo(policy.Enforced),
		shared.BoolToYesNo(policy.AllowAll),
		shared.BoolToYesNo(policy.DenyAll),
		shared.BoolToYesNo(policy.InheritParent),
	)

	if len(policy.AllowedValues) > 0 {
		lootFile.Contents += fmt.Sprintf("# Allowed Values: %s\n", strings.Join(policy.AllowedValues, ", "))
	}
	if len(policy.DeniedValues) > 0 {
		lootFile.Contents += fmt.Sprintf("# Denied Values: %s\n", strings.Join(policy.DeniedValues, ", "))
	}

	lootFile.Contents += fmt.Sprintf(
		"\n# Describe this policy:\n"+
			"gcloud org-policies describe %s --project=%s\n\n"+
			"# Get effective policy (includes inheritance):\n"+
			"gcloud org-policies describe %s --project=%s --effective\n\n",
		constraintName, policy.ProjectID,
		constraintName, policy.ProjectID,
	)
}

func (m *OrgPoliciesModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeHierarchicalOutput(ctx, logger)
	} else {
		m.writeFlatOutput(ctx, logger)
	}
}

func (m *OrgPoliciesModule) getHeader() []string {
	return []string{
		"Project Name",
		"Project ID",
		"Constraint",
		"Description",
		"Enforced",
		"Allow All",
		"Deny All",
		"Inherit",
		"Allowed Values",
		"Denied Values",
	}
}

func (m *OrgPoliciesModule) policiesToTableBody(policies []orgpolicyservice.OrgPolicyInfo) [][]string {
	var body [][]string
	for _, policy := range policies {
		description := policy.Description
		if description == "" {
			description = "-"
		}

		allowedValues := "-"
		if len(policy.AllowedValues) > 0 {
			allowedValues = strings.Join(policy.AllowedValues, ", ")
		}

		deniedValues := "-"
		if len(policy.DeniedValues) > 0 {
			deniedValues = strings.Join(policy.DeniedValues, ", ")
		}

		body = append(body, []string{
			m.GetProjectName(policy.ProjectID),
			policy.ProjectID,
			policy.Constraint,
			description,
			shared.BoolToYesNo(policy.Enforced),
			shared.BoolToYesNo(policy.AllowAll),
			shared.BoolToYesNo(policy.DenyAll),
			shared.BoolToYesNo(policy.InheritParent),
			allowedValues,
			deniedValues,
		})
	}
	return body
}

func (m *OrgPoliciesModule) buildTablesForProject(projectID string) []internal.TableFile {
	var tableFiles []internal.TableFile
	if policies, ok := m.ProjectPolicies[projectID]; ok && len(policies) > 0 {
		tableFiles = append(tableFiles, internal.TableFile{
			Name:   "orgpolicies",
			Header: m.getHeader(),
			Body:   m.policiesToTableBody(policies),
		})
	}
	return tableFiles
}

func (m *OrgPoliciesModule) writeHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	for projectID := range m.ProjectPolicies {
		tableFiles := m.buildTablesForProject(projectID)

		var lootFiles []internal.LootFile
		if projectLoot, ok := m.LootMap[projectID]; ok {
			for _, loot := range projectLoot {
				if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
					lootFiles = append(lootFiles, *loot)
				}
			}
		}

		outputData.ProjectLevelData[projectID] = OrgPoliciesOutput{Table: tableFiles, Loot: lootFiles}
	}

	pathBuilder := m.BuildPathBuilder()

	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}
}

func (m *OrgPoliciesModule) writeFlatOutput(ctx context.Context, logger internal.Logger) {
	allPolicies := m.getAllPolicies()

	var tables []internal.TableFile
	if len(allPolicies) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "orgpolicies",
			Header: m.getHeader(),
			Body:   m.policiesToTableBody(allPolicies),
		})
	}

	var lootFiles []internal.LootFile
	for _, projectLoot := range m.LootMap {
		for _, loot := range projectLoot {
			if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
				lootFiles = append(lootFiles, *loot)
			}
		}
	}

	output := OrgPoliciesOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		m.ProjectIDs,
		scopeNames,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}
}
