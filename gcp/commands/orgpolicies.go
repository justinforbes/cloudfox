package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	orgpolicyservice "github.com/BishopFox/cloudfox/gcp/services/orgpolicyService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPOrgPoliciesCommand = &cobra.Command{
	Use:     globals.GCP_ORGPOLICIES_MODULE_NAME,
	Aliases: []string{"orgpolicy", "policies"},
	Short:   "Enumerate organization policies and identify security weaknesses",
	Long: `Enumerate GCP organization policies to identify security configuration weaknesses.

Organization policies control security constraints across GCP resources. This module
identifies policies that may be misconfigured or weakened, creating security risks.

Security-Relevant Policies Analyzed:
- Domain restrictions (iam.allowedPolicyMemberDomains)
- Service account key controls (iam.disableServiceAccountKeyCreation)
- Workload identity restrictions
- Compute security (Shielded VM, OS Login, external IPs)
- Storage security (public access, uniform access)
- SQL security (public IPs, authorized networks)
- GKE security (public endpoints)
- Resource location restrictions

Risk Indicators:
- AllowAll: Policy allows any value (HIGH risk)
- Wildcard patterns: Overly permissive allowed values
- Unenforced: Security constraint not enabled
- Override: Project overrides parent restrictions`,
	Run: runGCPOrgPoliciesCommand,
}

type OrgPoliciesModule struct {
	gcpinternal.BaseGCPModule
	Policies []orgpolicyservice.OrgPolicyInfo
	LootMap  map[string]*internal.LootFile
	mu       sync.Mutex
}

type OrgPoliciesOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o OrgPoliciesOutput) TableFiles() []internal.TableFile { return o.Table }
func (o OrgPoliciesOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPOrgPoliciesCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_ORGPOLICIES_MODULE_NAME)
	if err != nil {
		return
	}

	module := &OrgPoliciesModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Policies:      []orgpolicyservice.OrgPolicyInfo{},
		LootMap:       make(map[string]*internal.LootFile),
	}
	module.initializeLootFiles()
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *OrgPoliciesModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_ORGPOLICIES_MODULE_NAME, m.processProject)

	if len(m.Policies) == 0 {
		logger.InfoM("No organization policies found (may require orgpolicy.policies.list permission)", globals.GCP_ORGPOLICIES_MODULE_NAME)
		return
	}

	// Count by risk level
	highCount := 0
	mediumCount := 0
	for _, policy := range m.Policies {
		switch policy.RiskLevel {
		case "HIGH":
			highCount++
		case "MEDIUM":
			mediumCount++
		}
	}

	logger.SuccessM(fmt.Sprintf("Found %d organization policy(ies) (%d HIGH, %d MEDIUM risk)",
		len(m.Policies), highCount, mediumCount), globals.GCP_ORGPOLICIES_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *OrgPoliciesModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating org policies in project: %s", projectID), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}

	svc := orgpolicyservice.New()
	policies, err := svc.ListProjectPolicies(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_ORGPOLICIES_MODULE_NAME,
			fmt.Sprintf("Could not enumerate org policies in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.Policies = append(m.Policies, policies...)
	for _, policy := range policies {
		m.addPolicyToLoot(policy)
	}
	m.mu.Unlock()
}

func (m *OrgPoliciesModule) initializeLootFiles() {
	m.LootMap["orgpolicies-all"] = &internal.LootFile{
		Name:     "orgpolicies-all",
		Contents: "# GCP Organization Policies\n# Generated by CloudFox\n\n",
	}
	m.LootMap["orgpolicies-weak"] = &internal.LootFile{
		Name:     "orgpolicies-weak",
		Contents: "# GCP Weak/Misconfigured Organization Policies\n# Generated by CloudFox\n# These policies may weaken security posture\n\n",
	}
	m.LootMap["orgpolicies-exploitation"] = &internal.LootFile{
		Name:     "orgpolicies-exploitation",
		Contents: "# GCP Organization Policy Exploitation Opportunities\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
}

func (m *OrgPoliciesModule) addPolicyToLoot(policy orgpolicyservice.OrgPolicyInfo) {
	// All policies
	m.LootMap["orgpolicies-all"].Contents += fmt.Sprintf(
		"## Constraint: %s\n"+
			"## Project: %s\n"+
			"## Enforced: %v\n"+
			"## AllowAll: %v, DenyAll: %v\n"+
			"## Inherit: %v\n"+
			"## Risk: %s\n",
		policy.Constraint,
		policy.ProjectID,
		policy.Enforced,
		policy.AllowAll, policy.DenyAll,
		policy.InheritParent,
		policy.RiskLevel,
	)
	if len(policy.AllowedValues) > 0 {
		m.LootMap["orgpolicies-all"].Contents += fmt.Sprintf("## Allowed: %s\n", strings.Join(policy.AllowedValues, ", "))
	}
	if len(policy.DeniedValues) > 0 {
		m.LootMap["orgpolicies-all"].Contents += fmt.Sprintf("## Denied: %s\n", strings.Join(policy.DeniedValues, ", "))
	}
	m.LootMap["orgpolicies-all"].Contents += "\n"

	// Weak policies
	if policy.RiskLevel == "HIGH" || policy.RiskLevel == "MEDIUM" {
		m.LootMap["orgpolicies-weak"].Contents += fmt.Sprintf(
			"## [%s] %s\n"+
				"## Project: %s\n"+
				"## Security Impact: %s\n",
			policy.RiskLevel, policy.Constraint,
			policy.ProjectID,
			policy.SecurityImpact,
		)
		if len(policy.RiskReasons) > 0 {
			m.LootMap["orgpolicies-weak"].Contents += "## Reasons:\n"
			for _, reason := range policy.RiskReasons {
				m.LootMap["orgpolicies-weak"].Contents += fmt.Sprintf("##   - %s\n", reason)
			}
		}
		m.LootMap["orgpolicies-weak"].Contents += "\n"

		// Add exploitation guidance for high-risk policies
		if policy.RiskLevel == "HIGH" {
			m.LootMap["orgpolicies-exploitation"].Contents += fmt.Sprintf(
				"## [%s] %s (Project: %s)\n"+
					"## Impact: %s\n",
				policy.RiskLevel, policy.Constraint, policy.ProjectID,
				policy.SecurityImpact,
			)
			m.LootMap["orgpolicies-exploitation"].Contents += m.getExploitationGuidance(policy)
			m.LootMap["orgpolicies-exploitation"].Contents += "\n"
		}
	}
}

func (m *OrgPoliciesModule) getExploitationGuidance(policy orgpolicyservice.OrgPolicyInfo) string {
	switch {
	case strings.Contains(policy.Constraint, "iam.allowedPolicyMemberDomains"):
		return "## Exploitation: Can add external users/SAs to IAM policies\n" +
			"# gcloud projects add-iam-policy-binding " + policy.ProjectID + " --member=user:external@evil.com --role=roles/viewer\n"
	case strings.Contains(policy.Constraint, "iam.disableServiceAccountKeyCreation"):
		return "## Exploitation: Can create persistent SA keys\n" +
			"# gcloud iam service-accounts keys create key.json --iam-account=SA_EMAIL\n"
	case strings.Contains(policy.Constraint, "compute.vmExternalIpAccess"):
		return "## Exploitation: Can create VMs with external IPs\n" +
			"# VMs can be created with public internet access\n"
	case strings.Contains(policy.Constraint, "storage.publicAccessPrevention"):
		return "## Exploitation: Can make buckets/objects public\n" +
			"# gsutil iam ch allUsers:objectViewer gs://BUCKET_NAME\n"
	case strings.Contains(policy.Constraint, "sql.restrictPublicIp"):
		return "## Exploitation: Can create Cloud SQL with public IP\n" +
			"# Database may be accessible from internet\n"
	case strings.Contains(policy.Constraint, "workloadIdentityPoolProviders"):
		return "## Exploitation: Can configure external identity providers\n" +
			"# External identities can assume GCP service account permissions\n"
	default:
		return "## Check constraint documentation for exploitation paths\n"
	}
}

func (m *OrgPoliciesModule) writeOutput(ctx context.Context, logger internal.Logger) {
	// Main policies table
	header := []string{
		"Constraint",
		"Risk",
		"Enforced",
		"AllowAll",
		"DenyAll",
		"Inherit",
		"Security Impact",
		"Project Name",
		"Project",
	}

	var body [][]string
	for _, policy := range m.Policies {
		impact := policy.SecurityImpact
		if len(impact) > 50 {
			impact = impact[:50] + "..."
		}

		body = append(body, []string{
			policy.Constraint,
			policy.RiskLevel,
			orgPolicyBoolToYesNo(policy.Enforced),
			orgPolicyBoolToYesNo(policy.AllowAll),
			orgPolicyBoolToYesNo(policy.DenyAll),
			orgPolicyBoolToYesNo(policy.InheritParent),
			impact,
			m.GetProjectName(policy.ProjectID),
			policy.ProjectID,
		})
	}

	// Weak policies table
	weakHeader := []string{
		"Risk",
		"Constraint",
		"Project Name",
		"Project",
		"Security Impact",
		"Reasons",
	}

	var weakBody [][]string
	for _, policy := range m.Policies {
		if policy.RiskLevel == "HIGH" || policy.RiskLevel == "MEDIUM" {
			reasons := strings.Join(policy.RiskReasons, "; ")
			if len(reasons) > 60 {
				reasons = reasons[:60] + "..."
			}

			weakBody = append(weakBody, []string{
				policy.RiskLevel,
				policy.Constraint,
				m.GetProjectName(policy.ProjectID),
				policy.ProjectID,
				policy.SecurityImpact,
				reasons,
			})
		}
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# Generated by CloudFox\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	tables := []internal.TableFile{
		{
			Name:   "orgpolicies",
			Header: header,
			Body:   body,
		},
	}

	if len(weakBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "orgpolicies-weak",
			Header: weakHeader,
			Body:   weakBody,
		})
		logger.InfoM(fmt.Sprintf("[PENTEST] Found %d weak/misconfigured organization policies!", len(weakBody)), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}

	output := OrgPoliciesOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		scopeNames,
		m.ProjectIDs,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}
}

func orgPolicyBoolToYesNo(b bool) string {
	if b {
		return "Yes"
	}
	return "No"
}
